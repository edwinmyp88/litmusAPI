[
    {
        "id": "781224d6064896f6",
        "type": "tab",
        "label": "scrapHist_ID",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8e44c4936852bf1d",
        "type": "tab",
        "label": "scrapHist_LAndM",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4b68bfc32f930f1c",
        "type": "tab",
        "label": "scrapCode",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "399ae0bbb6479748",
        "type": "tab",
        "label": "IncidentUser",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8599581f0e8197ce",
        "type": "tab",
        "label": "DT Duration",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5c83f8765f29479f",
        "type": "tab",
        "label": "scrap hist based on id",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "40dc11812e2f50cf",
        "type": "tab",
        "label": "DT history_Date",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "d51c145170155018",
        "type": "tab",
        "label": "Add IncidentResp User",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "eac46d969b6a844c",
        "type": "tab",
        "label": "Flow 10",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "83c3ec36bf6fe84f",
        "type": "tab",
        "label": "Flow 15",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "0a31cc0a49282f6b",
        "type": "tab",
        "label": "endpoint (using headers)",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "a215c175be6747f4",
        "type": "tab",
        "label": "Create new account",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "07faf086ce88aab0",
        "type": "tab",
        "label": "Email notification",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "74d4b18460046b49",
        "type": "tab",
        "label": "Update Inventory",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "cabe4ab3486d8daf",
        "type": "tab",
        "label": "PCBFailure_sim",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "d516f4c69dd3bbfe",
        "type": "tab",
        "label": "LIVE endpoint backup",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "aba326dbe5621f19",
        "type": "tab",
        "label": "Streamlit Login",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5e4c90fefbab90d1",
        "type": "tab",
        "label": "Streamlit Load table",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1edb4a8c4511a724",
        "type": "tab",
        "label": "Litmus AutoML table query",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "2e2aa3d68094aba1",
        "type": "subflow",
        "name": "Subflow 1",
        "info": "",
        "in": [],
        "out": []
    },
    {
        "id": "99aa93fffde390a2",
        "type": "MSSQL-CN",
        "name": "litmus",
        "server": "192.168.0.232",
        "port": "",
        "encyption": false,
        "trustServerCertificate": false,
        "database": "",
        "useUTC": false,
        "connectTimeout": "",
        "requestTimeout": "",
        "cancelTimeout": "",
        "pool": "",
        "parseJSON": false,
        "enableArithAbort": true,
        "readOnlyIntent": false
    },
    {
        "id": "3a108e85f3c6ac98",
        "type": "MSSQL-CN",
        "tdsVersion": "7_4",
        "name": "Litmus Live",
        "server": "192.168.0.188",
        "port": "1433",
        "encyption": true,
        "trustServerCertificate": true,
        "database": "litmus",
        "useUTC": true,
        "connectTimeout": "15000",
        "requestTimeout": "15000",
        "cancelTimeout": "5000",
        "pool": "5",
        "parseJSON": false,
        "enableArithAbort": true,
        "readOnlyIntent": false
    },
    {
        "id": "67276a6374171bac",
        "type": "subflow:2e2aa3d68094aba1",
        "z": "2e2aa3d68094aba1",
        "name": "",
        "x": 400,
        "y": 180,
        "wires": []
    },
    {
        "id": "9348b5c869f38884",
        "type": "debug",
        "z": "781224d6064896f6",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 120,
        "wires": []
    },
    {
        "id": "fee91fa4c4ce8fbc",
        "type": "function",
        "z": "781224d6064896f6",
        "name": "Query ",
        "func": "let id = msg.payload.id;\nmsg.topic = 'SELECT * FROM litmus.dbo.scrapHistory WHERE id = @id';\n\nmsg.payload = [{\n    \"name\": \"id\",\n    \"value\": id,\n    \"type\": \"Int\"\n}];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 140,
        "wires": [
            [
                "86d5c79e8b997f4c"
            ]
        ]
    },
    {
        "id": "86d5c79e8b997f4c",
        "type": "MSSQL",
        "z": "781224d6064896f6",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 900,
        "y": 140,
        "wires": [
            [
                "eaf95650aebc800e",
                "9348b5c869f38884"
            ]
        ]
    },
    {
        "id": "76d930f112b2eef8",
        "type": "http in",
        "z": "781224d6064896f6",
        "name": "",
        "url": "/api/litmus/scrapHistory/id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 160,
        "wires": [
            [
                "61aa3f13f032ea3d"
            ]
        ]
    },
    {
        "id": "eaf95650aebc800e",
        "type": "http response",
        "z": "781224d6064896f6",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1100,
        "y": 160,
        "wires": []
    },
    {
        "id": "8c1acad8d24d06ff",
        "type": "comment",
        "z": "781224d6064896f6",
        "name": "Get Scrap History by ID",
        "info": "",
        "x": 160,
        "y": 60,
        "wires": []
    },
    {
        "id": "91b89bdabd162dbd",
        "type": "http response",
        "z": "781224d6064896f6",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 740,
        "y": 180,
        "wires": []
    },
    {
        "id": "61aa3f13f032ea3d",
        "type": "rate-limiter",
        "z": "781224d6064896f6",
        "delay_action": "ratelimit",
        "rate": "100",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 490,
        "y": 160,
        "wires": [
            [
                "fee91fa4c4ce8fbc"
            ],
            [
                "91b89bdabd162dbd"
            ]
        ]
    },
    {
        "id": "4516e0f829afa3f9",
        "type": "debug",
        "z": "8e44c4936852bf1d",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 200,
        "wires": []
    },
    {
        "id": "7e6e9a105ee304ac",
        "type": "function",
        "z": "8e44c4936852bf1d",
        "name": "function 2",
        "func": "let line, asset;\nif (msg.req && msg.req.query){\n    line = msg.req.query.line;\n    asset = msg.req.query.asset;\n} else {\n    line = msg.payload.line;\n    asset = msg.payload.asset;\n}\nmsg.topic = 'SELECT TOP 100 * FROM litmus.dbo.scrapHistory WHERE line = @line AND asset = @asset';\n\nmsg.payload = [\n    { name: \"line\", type: \"VarChar\", value: line },\n    { name: \"asset\", type: \"Varchar\", value: asset}\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 200,
        "wires": [
            [
                "b8899be5a56ca909",
                "2dc3755ef77f1a54"
            ]
        ]
    },
    {
        "id": "b8899be5a56ca909",
        "type": "MSSQL",
        "z": "8e44c4936852bf1d",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 940,
        "y": 200,
        "wires": [
            [
                "4516e0f829afa3f9",
                "c3584ec5ea25f064"
            ]
        ]
    },
    {
        "id": "2dc3755ef77f1a54",
        "type": "debug",
        "z": "8e44c4936852bf1d",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 260,
        "wires": []
    },
    {
        "id": "efe9628fe980f975",
        "type": "http in",
        "z": "8e44c4936852bf1d",
        "name": "",
        "url": "/api/litmus/scrapHistory/lineandmachine",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 220,
        "wires": [
            [
                "5405e7be0837aaaa"
            ]
        ]
    },
    {
        "id": "c3584ec5ea25f064",
        "type": "http response",
        "z": "8e44c4936852bf1d",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1120,
        "y": 240,
        "wires": []
    },
    {
        "id": "90bbc66fb2da96f6",
        "type": "comment",
        "z": "8e44c4936852bf1d",
        "name": "Get scrap history by line number and machine number",
        "info": "",
        "x": 220,
        "y": 60,
        "wires": []
    },
    {
        "id": "2952e54a9a1b6e39",
        "type": "http response",
        "z": "8e44c4936852bf1d",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 740,
        "y": 240,
        "wires": []
    },
    {
        "id": "5405e7be0837aaaa",
        "type": "rate-limiter",
        "z": "8e44c4936852bf1d",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 520,
        "y": 220,
        "wires": [
            [
                "7e6e9a105ee304ac"
            ],
            [
                "2952e54a9a1b6e39"
            ]
        ]
    },
    {
        "id": "dc969e02096fc6bf",
        "type": "comment",
        "z": "4b68bfc32f930f1c",
        "name": "Get scrap description by scrap code",
        "info": "",
        "x": 200,
        "y": 60,
        "wires": []
    },
    {
        "id": "c9364029b045fddf",
        "type": "debug",
        "z": "4b68bfc32f930f1c",
        "name": "debug 5",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 120,
        "wires": []
    },
    {
        "id": "4f98634dc1e852fd",
        "type": "function",
        "z": "4b68bfc32f930f1c",
        "name": "Query",
        "func": "let scrapCodes = msg.payload.scrapCodes;\nmsg.topic = 'SELECT scrapCode, scrapCode_text FROM litmus.dbo.scrapCodes;'\nmsg.payload = [{\n    name: \"scrapCode\",\n    type: \"Int\",\n    value: scrapCodes\n}];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 160,
        "wires": [
            [
                "ba25ded17b921c9a",
                "d5830ca0a8639598"
            ]
        ]
    },
    {
        "id": "ba25ded17b921c9a",
        "type": "MSSQL",
        "z": "4b68bfc32f930f1c",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 880,
        "y": 160,
        "wires": [
            [
                "c9364029b045fddf",
                "96a2a3701b0cb522"
            ]
        ]
    },
    {
        "id": "d5830ca0a8639598",
        "type": "debug",
        "z": "4b68bfc32f930f1c",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 120,
        "wires": []
    },
    {
        "id": "96a2a3701b0cb522",
        "type": "http response",
        "z": "4b68bfc32f930f1c",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1060,
        "y": 160,
        "wires": []
    },
    {
        "id": "93515414cba9135f",
        "type": "http in",
        "z": "4b68bfc32f930f1c",
        "name": "",
        "url": "api/litmus/scrapCode",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 180,
        "wires": [
            [
                "f85dc88c1d4a6551"
            ]
        ]
    },
    {
        "id": "f85dc88c1d4a6551",
        "type": "rate-limiter",
        "z": "4b68bfc32f930f1c",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 480,
        "y": 180,
        "wires": [
            [
                "4f98634dc1e852fd"
            ],
            [
                "72709647b8574185"
            ]
        ]
    },
    {
        "id": "72709647b8574185",
        "type": "http response",
        "z": "4b68bfc32f930f1c",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 700,
        "y": 200,
        "wires": []
    },
    {
        "id": "43d899a8f339ddc5",
        "type": "comment",
        "z": "399ae0bbb6479748",
        "name": "Get user information (incident response team)",
        "info": "",
        "x": 230,
        "y": 60,
        "wires": []
    },
    {
        "id": "f26d354e134f88eb",
        "type": "debug",
        "z": "399ae0bbb6479748",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 140,
        "wires": []
    },
    {
        "id": "9f9b3249a44808b4",
        "type": "function",
        "z": "399ae0bbb6479748",
        "name": "function 4",
        "func": "let id = msg.payload.id;\nmsg.topic = 'SELECT * FROM litmus.dbo.incident_user WHERE id = @id';\n\nmsg.payload = [{\n    \"name\": \"id\",\n    \"value\": id,\n    \"type\": \"VarChar\"\n}];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 180,
        "wires": [
            [
                "6cdb09f23bb35a6a",
                "60a8593c81f11147"
            ]
        ]
    },
    {
        "id": "6cdb09f23bb35a6a",
        "type": "MSSQL",
        "z": "399ae0bbb6479748",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 840,
        "y": 180,
        "wires": [
            [
                "f26d354e134f88eb",
                "b6c72982e30c90da"
            ]
        ]
    },
    {
        "id": "60a8593c81f11147",
        "type": "debug",
        "z": "399ae0bbb6479748",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 140,
        "wires": []
    },
    {
        "id": "2b189ffcb47cd3fb",
        "type": "http in",
        "z": "399ae0bbb6479748",
        "name": "",
        "url": "/api/litmus/incidentUser",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 200,
        "wires": [
            [
                "6d54ac6c8b54e4bc"
            ]
        ]
    },
    {
        "id": "b6c72982e30c90da",
        "type": "http response",
        "z": "399ae0bbb6479748",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1020,
        "y": 180,
        "wires": []
    },
    {
        "id": "6d54ac6c8b54e4bc",
        "type": "rate-limiter",
        "z": "399ae0bbb6479748",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 420,
        "y": 200,
        "wires": [
            [
                "9f9b3249a44808b4"
            ],
            [
                "c1e24d5c38f68e27"
            ]
        ]
    },
    {
        "id": "c1e24d5c38f68e27",
        "type": "http response",
        "z": "399ae0bbb6479748",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 660,
        "y": 220,
        "wires": []
    },
    {
        "id": "28d0ad7ea3b6b64d",
        "type": "comment",
        "z": "8599581f0e8197ce",
        "name": "Get event details based on downtime duration",
        "info": "",
        "x": 210,
        "y": 60,
        "wires": []
    },
    {
        "id": "48d3fec26bd6e648",
        "type": "debug",
        "z": "8599581f0e8197ce",
        "name": "debug 9",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 120,
        "wires": []
    },
    {
        "id": "afbf8f8d236b72fa",
        "type": "function",
        "z": "8599581f0e8197ce",
        "name": "function 5",
        "func": "let duration = msg.payload.duration;\nmsg.topic = 'SELECT TOP 100 * FROM litmus.dbo.downtimeHistory WHERE duration > @duration ORDER BY duration';\n\nmsg.payload = [{\n    \"name\": \"duration\",\n    \"value\": duration,\n    \"type\": \"Int\"\n}];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 160,
        "wires": [
            [
                "2dcf320f50960c13",
                "4fb286823981e7b1"
            ]
        ]
    },
    {
        "id": "2dcf320f50960c13",
        "type": "MSSQL",
        "z": "8599581f0e8197ce",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 880,
        "y": 160,
        "wires": [
            [
                "48d3fec26bd6e648",
                "d9084b4f0eb2d21a"
            ]
        ]
    },
    {
        "id": "4fb286823981e7b1",
        "type": "debug",
        "z": "8599581f0e8197ce",
        "name": "debug 10",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 120,
        "wires": []
    },
    {
        "id": "f67f7d0bbfac97b8",
        "type": "http in",
        "z": "8599581f0e8197ce",
        "name": "",
        "url": "/api/litmus/downtimeHistory/duration",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 180,
        "wires": [
            [
                "78f38c616b0752d4"
            ]
        ]
    },
    {
        "id": "d9084b4f0eb2d21a",
        "type": "http response",
        "z": "8599581f0e8197ce",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1060,
        "y": 160,
        "wires": []
    },
    {
        "id": "78f38c616b0752d4",
        "type": "rate-limiter",
        "z": "8599581f0e8197ce",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 460,
        "y": 180,
        "wires": [
            [
                "afbf8f8d236b72fa"
            ],
            [
                "340f27c014bdf78d"
            ]
        ]
    },
    {
        "id": "340f27c014bdf78d",
        "type": "http response",
        "z": "8599581f0e8197ce",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 680,
        "y": 200,
        "wires": []
    },
    {
        "id": "dfc2a43df4970d8f",
        "type": "comment",
        "z": "5c83f8765f29479f",
        "name": "Get scrap history based on user id",
        "info": "",
        "x": 200,
        "y": 60,
        "wires": []
    },
    {
        "id": "23c753c8f17d9759",
        "type": "debug",
        "z": "5c83f8765f29479f",
        "name": "debug 11",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 120,
        "wires": []
    },
    {
        "id": "443b8e4045390438",
        "type": "function",
        "z": "5c83f8765f29479f",
        "name": "function 6",
        "func": "let id = msg.payload.id;\n\n// Create an object for the parameters\n// It should match the expected format by the MSSQL-PLUS node\n//msg.payload = {}; // Clearing payload for MSSQL-PLUS to avoid conflicts\nmsg.parameters = [\n    {\n        name: \"id\",\n        value: id,\n        type: \"Int\"\n    }\n];\n\nmsg.topic = \"SELECT * FROM litmus.dbo.scrapHistory WHERE id = @id\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 160,
        "wires": [
            [
                "cffe2fb97d73f00c",
                "a17b4cd3eefb6725"
            ]
        ]
    },
    {
        "id": "cffe2fb97d73f00c",
        "type": "MSSQL",
        "z": "5c83f8765f29479f",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "parameters",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 860,
        "y": 160,
        "wires": [
            [
                "23c753c8f17d9759",
                "fd61353cb12c6c31"
            ]
        ]
    },
    {
        "id": "a17b4cd3eefb6725",
        "type": "debug",
        "z": "5c83f8765f29479f",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 120,
        "wires": []
    },
    {
        "id": "1f32b1806a25fc78",
        "type": "http in",
        "z": "5c83f8765f29479f",
        "name": "",
        "url": "/api/litmus/scrapHistory",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 160,
        "wires": [
            [
                "b575dd672afa96f5"
            ]
        ]
    },
    {
        "id": "fd61353cb12c6c31",
        "type": "http response",
        "z": "5c83f8765f29479f",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1080,
        "y": 160,
        "wires": []
    },
    {
        "id": "b575dd672afa96f5",
        "type": "rate-limiter",
        "z": "5c83f8765f29479f",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 420,
        "y": 160,
        "wires": [
            [
                "443b8e4045390438"
            ],
            [
                "9ae53f6290aa27fd"
            ]
        ]
    },
    {
        "id": "9ae53f6290aa27fd",
        "type": "http response",
        "z": "5c83f8765f29479f",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 680,
        "y": 200,
        "wires": []
    },
    {
        "id": "960df8f164e33d4e",
        "type": "debug",
        "z": "40dc11812e2f50cf",
        "name": "debug 13",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 120,
        "wires": []
    },
    {
        "id": "1375e0f0355055a4",
        "type": "function",
        "z": "40dc11812e2f50cf",
        "name": "function 7",
        "func": "let startDate = msg.payload.startDate;\nlet endDate = msg.payload.endDate;\n\nmsg.topic = 'SELECT TOP 1000 * FROM litmus.dbo.downtimeHistory WHERE CAST(startTime AS DATE) BETWEEN @startDate AND @endDate';\n\nmsg.payload = [\n    { name: 'startDate', type: 'VarChar', value: startDate },\n    { name: 'endDate', type: 'VarChar', value: endDate }\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 160,
        "wires": [
            [
                "98057de77ed16e04",
                "28bd29016a5b4686"
            ]
        ]
    },
    {
        "id": "98057de77ed16e04",
        "type": "MSSQL",
        "z": "40dc11812e2f50cf",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 900,
        "y": 160,
        "wires": [
            [
                "960df8f164e33d4e",
                "ac483d34c67e2020"
            ]
        ]
    },
    {
        "id": "28bd29016a5b4686",
        "type": "debug",
        "z": "40dc11812e2f50cf",
        "name": "debug 14",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 880,
        "y": 120,
        "wires": []
    },
    {
        "id": "c703665f7f407701",
        "type": "http in",
        "z": "40dc11812e2f50cf",
        "name": "",
        "url": "api/litmus/downtimeHistory/Date",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 180,
        "wires": [
            [
                "13aab7a688bd9865"
            ]
        ]
    },
    {
        "id": "ac483d34c67e2020",
        "type": "http response",
        "z": "40dc11812e2f50cf",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1080,
        "y": 160,
        "wires": []
    },
    {
        "id": "049bb4bfd0390a9e",
        "type": "comment",
        "z": "40dc11812e2f50cf",
        "name": "Get Downtime History by Date",
        "info": "",
        "x": 180,
        "y": 60,
        "wires": []
    },
    {
        "id": "0f703ff7bc9aac93",
        "type": "http response",
        "z": "40dc11812e2f50cf",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 720,
        "y": 200,
        "wires": []
    },
    {
        "id": "13aab7a688bd9865",
        "type": "rate-limiter",
        "z": "40dc11812e2f50cf",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 480,
        "y": 180,
        "wires": [
            [
                "1375e0f0355055a4"
            ],
            [
                "0f703ff7bc9aac93"
            ]
        ]
    },
    {
        "id": "c60e2b01596fb797",
        "type": "debug",
        "z": "d51c145170155018",
        "name": "debug 15",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 140,
        "wires": []
    },
    {
        "id": "a39350619f4f2b9c",
        "type": "function",
        "z": "d51c145170155018",
        "name": "Data insertion",
        "func": "if (!msg.duplicateFound){\n    msg.topic = 'INSERT INTO litmus.dbo.incident_user (id, username, firstname, lastname, email, mobile, telegramID, team) VALUES (@id, @username, @firstname, @lastname, @email, @mobile, @telegramID, @team)';\n    msg.payload = [\n        { name: 'id', type: 'VarChar', value: msg.payload.id },\n        { name: 'username', type: 'VarChar', value: msg.payload.username },\n        { name: 'firstname', type: 'VarChar', value: msg.payload.firstname },\n        { name: 'lastname', type: 'VarChar', value: msg.payload.lastname },\n        { name: 'email', type: 'VarChar', value: msg.payload.email },\n        { name: 'mobile', type: 'VarChar', value: msg.payload.mobile },\n        { name: 'telegramID', type: 'VarChar', value: msg.payload.telegramID },\n        { name: 'team', type: 'VarChar', value: msg.payload.team }\n    ];\n} else {\n    msg.topic = 'INSERT INTO litmus.dbo.incident_user (id, username, firstname, lastname, email, mobile, telegramID, team) VALUES (NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)';\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 180,
        "wires": [
            [
                "17141778da9eb3e0",
                "3a612ff78f8ffd58"
            ]
        ]
    },
    {
        "id": "17141778da9eb3e0",
        "type": "MSSQL",
        "z": "d51c145170155018",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 1480,
        "y": 180,
        "wires": [
            [
                "c60e2b01596fb797",
                "4cbb3363ec45599e"
            ]
        ]
    },
    {
        "id": "3a612ff78f8ffd58",
        "type": "debug",
        "z": "d51c145170155018",
        "name": "debug 16",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 140,
        "wires": []
    },
    {
        "id": "dd5083fb0c53bce9",
        "type": "http in",
        "z": "d51c145170155018",
        "name": "",
        "url": "/api/litmus/incidentResponse",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 180,
        "wires": [
            [
                "d449c05723a8dbf5"
            ]
        ]
    },
    {
        "id": "4cbb3363ec45599e",
        "type": "http response",
        "z": "d51c145170155018",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1660,
        "y": 180,
        "wires": []
    },
    {
        "id": "01c36b13677cd0a7",
        "type": "comment",
        "z": "d51c145170155018",
        "name": "Add new incident response team",
        "info": "",
        "x": 190,
        "y": 60,
        "wires": []
    },
    {
        "id": "bc92896523fae652",
        "type": "function",
        "z": "d51c145170155018",
        "name": "Duplication checker",
        "func": "msg.topic = 'SELECT COUNT(*) AS count FROM litmus.dbo.incident_user WHERE id = @id AND username = @username';\nmsg.params = [\n    { name: 'id', type: 'VarChar', value: msg.payload.id },\n    { name: 'username', type: 'VarChar', value: msg.payload.username }\n];\n\nmsg.originalPayload = msg.payload;\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 180,
        "wires": [
            [
                "8a00b331b59ff507",
                "c44ad62c2535c1b1"
            ]
        ]
    },
    {
        "id": "4d40e03758c4c8c4",
        "type": "function",
        "z": "d51c145170155018",
        "name": "Result handling",
        "func": "if (msg.payload && msg.payload[0].count > 0){\n    node.error(\"Duplicate entry found for username.\");\n    return null;\n} else {\n    msg.payload = msg.originalPayload;\n    return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 180,
        "wires": [
            [
                "31cef844bd95dd00",
                "a39350619f4f2b9c"
            ]
        ]
    },
    {
        "id": "31cef844bd95dd00",
        "type": "debug",
        "z": "d51c145170155018",
        "name": "debug 17",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 140,
        "wires": []
    },
    {
        "id": "c44ad62c2535c1b1",
        "type": "MSSQL",
        "z": "d51c145170155018",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "params",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": false,
        "params": [],
        "x": 880,
        "y": 180,
        "wires": [
            [
                "4d40e03758c4c8c4"
            ]
        ]
    },
    {
        "id": "8a00b331b59ff507",
        "type": "debug",
        "z": "d51c145170155018",
        "name": "debug 18",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 140,
        "wires": []
    },
    {
        "id": "d449c05723a8dbf5",
        "type": "rate-limiter",
        "z": "d51c145170155018",
        "delay_action": "ratelimit",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 440,
        "y": 180,
        "wires": [
            [
                "bc92896523fae652"
            ],
            [
                "ef061b1c45be61d9"
            ]
        ]
    },
    {
        "id": "ef061b1c45be61d9",
        "type": "http response",
        "z": "d51c145170155018",
        "name": "",
        "statusCode": "429",
        "headers": {},
        "x": 640,
        "y": 220,
        "wires": []
    },
    {
        "id": "65e36494996e4e9d",
        "type": "inject",
        "z": "d51c145170155018",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"id\":\"1\",\"username\":\"yz\",\"firstname\":\"Sebastian\",\"lastname\":\"tan\",\"email\":\"tctan@gmail.com\",\"mobile\":\"0184810228\",\"telegramID\":\"123456789\",\"team\":\"{T001}\"}",
        "payloadType": "json",
        "x": 230,
        "y": 220,
        "wires": [
            [
                "d449c05723a8dbf5"
            ]
        ]
    },
    {
        "id": "45a42f96b2adcf1b",
        "type": "template",
        "z": "eac46d969b6a844c",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "This is the payload: {{payload}} !",
        "output": "str",
        "x": 380,
        "y": 200,
        "wires": [
            [
                "dba48609cf146586",
                "5bab59da022da185"
            ]
        ]
    },
    {
        "id": "7fc7a9582e9ad84b",
        "type": "inject",
        "z": "eac46d969b6a844c",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "First Testing",
        "payload": "This is a test message",
        "payloadType": "str",
        "x": 180,
        "y": 220,
        "wires": [
            [
                "45a42f96b2adcf1b"
            ]
        ]
    },
    {
        "id": "dba48609cf146586",
        "type": "debug",
        "z": "eac46d969b6a844c",
        "name": "debug 19",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 180,
        "wires": []
    },
    {
        "id": "0caeb1a652ee14c9",
        "type": "http in",
        "z": "eac46d969b6a844c",
        "name": "",
        "url": "/testing",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 180,
        "wires": [
            [
                "45a42f96b2adcf1b"
            ]
        ]
    },
    {
        "id": "5bab59da022da185",
        "type": "http response",
        "z": "eac46d969b6a844c",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 590,
        "y": 220,
        "wires": []
    },
    {
        "id": "d280e90027e1e020",
        "type": "comment",
        "z": "eac46d969b6a844c",
        "name": "Test",
        "info": "",
        "x": 90,
        "y": 40,
        "wires": []
    },
    {
        "id": "82a9754dfae5081f",
        "type": "http response",
        "z": "83c3ec36bf6fe84f",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 960,
        "y": 180,
        "wires": []
    },
    {
        "id": "08ed949e3f2fed79",
        "type": "debug",
        "z": "83c3ec36bf6fe84f",
        "name": "debug 33",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 140,
        "wires": []
    },
    {
        "id": "b7f6526d44887857",
        "type": "MSSQL",
        "z": "83c3ec36bf6fe84f",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "params",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 760,
        "y": 180,
        "wires": [
            [
                "08ed949e3f2fed79",
                "82a9754dfae5081f"
            ]
        ]
    },
    {
        "id": "bce543bb8f2d2b06",
        "type": "rate-limiter",
        "z": "83c3ec36bf6fe84f",
        "delay_action": "ratelimit",
        "rate": "12",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 340,
        "y": 200,
        "wires": [
            [
                "f6fdf6371a7c1a23"
            ],
            [
                "9fa131a0d2938d99"
            ]
        ]
    },
    {
        "id": "69acf90f4aaaf214",
        "type": "debug",
        "z": "83c3ec36bf6fe84f",
        "name": "debug 35",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 140,
        "wires": []
    },
    {
        "id": "f6fdf6371a7c1a23",
        "type": "function",
        "z": "83c3ec36bf6fe84f",
        "name": "Main function",
        "func": "const requestBody = msg.payload;\nlet tableName = \"\";\nconst DEFAULT_COUNT = 10;\nconst {\n    method,\n    count = DEFAULT_COUNT\n} = requestBody;\n\nswitch (method) {\n    case \"anomalyHistory\":\n        tableName = \"litmus.dbo.anomalyHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi17\":\n        tableName = \"litmus.dbo.avi17\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi1718\":\n        tableName = \"litmus.dbo.avi1718\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi999\":\n        tableName = \"litmus.dbo.avi999\";\n        break;  // Prevent fall-through with a break statement\n    case \"downtimeHistory\":\n        tableName = \"litmus.dbo.downtimeHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"enigparam\":\n        tableName = \"litmus.dbo.enigparam\";\n        break;  // Prevent fall-through with a break statement\n    case \"filedrop\":\n        tableName = \"litmus.dbo.filedrop\";\n        break;  // Prevent fall-through with a break statement\n    case \"incident\":\n        tableName = \"litmus.dbo.incident\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentMonitor\":\n        tableName = \"litmus.dbo.incident_monitor\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentSop\":\n        tableName = \"litmus.dbo.incident_sop\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentTeam\":\n        tableName = \"litmus.dbo.incident_team\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentUser\":\n        tableName = \"litmus.dbo.incident_user\";\n        break;  // Prevent fall-through with a break statement\n    case \"jimiiotDevices\":\n        tableName = \"litmus.dbo.jimiiotDevices\";\n        break;  // Prevent fall-through with a break statement\n    case \"MLTrain\":\n        tableName = \"litmus.dbo.MLTrain\";\n        break;  // Prevent fall-through with a break statement\n    case \"modelFeature\":\n        tableName = \"litmus.dbo.modelfeature\";\n        break;  // Prevent fall-through with a break statement\n    case \"pcb_enig\":\n        tableName = \"litmus.dbo.pcb_enig\";\n        break;  // Prevent fall-through with a break statement\n    case \"pcb_thickness\":\n        tableName = \"litmus.dbo.pcb_thickness\";\n        break;  // Prevent fall-through with a break statement\n    case \"reasonCodes\":\n        tableName = \"litmus.dbo.reasonCodes\";\n        break;  // Prevent fall-through with a break statement\n    case \"scrapCodes\":\n        tableName = \"litmus.dbo.scrapCodes\";\n        break;  // Prevent fall-through with a break statement\n    case \"scrapHistory\":\n        tableName = \"litmus.dbo.scrapHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"spc\":\n        tableName = \"litmus.dbo.spc\";\n        break;  // Prevent fall-through with a break statement\n    case \"trackAsset\":\n        tableName = \"litmus.dbo.track_asset\";\n        break;  // Prevent fall-through with a break statement\n    default:\n        // Handle unknown method\n        msg.payload = {\n            error: true,\n            message: \"Invalid 'method' specified in the request.\"\n        };\n        msg.statusCode = 400; // Bad Request HTTP status code\n        return msg; // Stop execution and return error message\n}\n\nmsg.topic = `SELECT TOP ${count} * FROM ${tableName}`;\n\n// If dateFrom and dateTo are provided and applicable, add a WHERE clause\n/*if (dateFrom && dateTo) {\n    // You should also ensure that dateFrom and dateTo are in the correct format\n    // and sanitized to prevent SQL injection\n    sqlQuery += ` WHERE Date BETWEEN '${dateFrom}' AND '${dateTo}' `;\n}*/\n\n// Continue with the flow\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 180,
        "wires": [
            [
                "69acf90f4aaaf214",
                "b7f6526d44887857"
            ]
        ]
    },
    {
        "id": "9fa131a0d2938d99",
        "type": "http response",
        "z": "83c3ec36bf6fe84f",
        "name": "",
        "statusCode": "401",
        "headers": {},
        "x": 560,
        "y": 220,
        "wires": []
    },
    {
        "id": "8b51d6f37041e88a",
        "type": "http in",
        "z": "83c3ec36bf6fe84f",
        "name": "",
        "url": "/litmusTest",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 200,
        "wires": [
            [
                "bce543bb8f2d2b06"
            ]
        ]
    },
    {
        "id": "b7ee72f2c446bd1a",
        "type": "comment",
        "z": "83c3ec36bf6fe84f",
        "name": "Generic endpoint (Test)",
        "info": "",
        "x": 120,
        "y": 80,
        "wires": []
    },
    {
        "id": "079b8045732a664f",
        "type": "http in",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "url": "/api/litmusAuth",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 320,
        "wires": [
            [
                "3210c5ac1f589c9a"
            ]
        ]
    },
    {
        "id": "e3a9884c89bf31f7",
        "type": "comment",
        "z": "0a31cc0a49282f6b",
        "name": "Generic endpoint (Header Main)",
        "info": "",
        "x": 150,
        "y": 40,
        "wires": []
    },
    {
        "id": "9327b20a44789beb",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "OK",
        "statusCode": "200",
        "headers": {},
        "x": 1570,
        "y": 580,
        "wires": []
    },
    {
        "id": "df34dfb2cfa6bef6",
        "type": "MSSQL",
        "z": "0a31cc0a49282f6b",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "query2",
        "queryOptType": "msg",
        "paramsOpt": "params",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 1260,
        "y": 600,
        "wires": [
            [
                "aa85b13a4fc115c7",
                "9327b20a44789beb"
            ]
        ]
    },
    {
        "id": "8bf024e8b779e02d",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1260,
        "y": 320,
        "wires": []
    },
    {
        "id": "fb404e15e0f27600",
        "type": "rate-limiter",
        "z": "0a31cc0a49282f6b",
        "delay_action": "ratelimit",
        "rate": "12",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 740,
        "y": 500,
        "wires": [
            [
                "ca79552f261b5026"
            ],
            [
                "ac9fd088939df164"
            ]
        ]
    },
    {
        "id": "3f98daaf13bd9731",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 43",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 340,
        "wires": []
    },
    {
        "id": "b0c784a282211e58",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Decode Auth header",
        "func": "if (msg.req.headers.authorization) {\n    const encodedCredentials = msg.req.headers.authorization.split(' ')[1];\n    const decodedCredentials = Buffer.from(encodedCredentials, 'base64').toString('ascii');\n    const [username, password] = decodedCredentials.split(':');\n    msg.credentials = { username, password };\n    return msg; // Pass the credentials to the next node for verification\n} else {\n    \n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 400,
        "wires": [
            [
                "0fde76f0f98315a9"
            ]
        ]
    },
    {
        "id": "da64a4ebfa5b2aef",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 44",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1000,
        "y": 480,
        "wires": []
    },
    {
        "id": "ecf8c44443b7d797",
        "type": "MSSQL",
        "z": "0a31cc0a49282f6b",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "SELECT PasswordHash FROM litmus.dbo.api_user WHERE Username = @username",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "query",
        "queryOptType": "msg",
        "paramsOpt": "params",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 1160,
        "y": 400,
        "wires": [
            [
                "8bf024e8b779e02d",
                "559cd504c820bba0"
            ]
        ]
    },
    {
        "id": "179a33cf508b74f2",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Credentials Verification",
        "func": "const bcrypt = global.get('bcrypt');\n// Assuming the hashed password is retrieved and stored in msg.payload[0].PasswordHash\n// and the plaintext password provided by the user is in msg.payload.password\n\n// Ensure you're accessing the hashedPassword correctly based on the actual structure of msg.payload\nconst hashedPassword = msg.database.hashedPassword;  // Or msg.payload.PasswordHash if not an array\nconst plaintextPassword = msg.credentials.password;  // The plaintext password from the auth header\n\nbcrypt.compare(plaintextPassword, hashedPassword, function (err, result) {\n    if (err) {\n        // Handle error\n        node.error('Error comparing passwords', err);\n        msg.statusCode = 500;\n        msg.payload = \"Internal server error.\";\n        node.send([null, msg]); // Stop the flow and respond with an error\n    } else if (result) {\n        // Passwords match\n        msg.statusCode = 200;\n        msg.payload = \"Authentication successful.\";\n        node.send([msg, null]); // Continue the flow (if there's more to do) or respond\n    } else {\n        // Passwords do not match\n        msg.statusCode = 401;\n        msg.payload = \"Invalid credentials.\";\n        node.send([null, msg]); // Stop the flow and respond with an error\n    }\n\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 400,
        "wires": [
            [
                "c1abd451b24faea6",
                "fb404e15e0f27600"
            ]
        ]
    },
    {
        "id": "559cd504c820bba0",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Retrieved hashed password",
        "func": "// After the MSSQL node\nmsg.database = { hashedPassword: msg.payload[0].password };\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 400,
        "wires": [
            [
                "179a33cf508b74f2",
                "5e126690535e5fc6"
            ]
        ]
    },
    {
        "id": "c1abd451b24faea6",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 45",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1760,
        "y": 360,
        "wires": []
    },
    {
        "id": "ca79552f261b5026",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Main function",
        "func": "const requestBody = msg.payload;\nconst calledMethod = msg.method;\n//const api_key = msg.req.query.api_key;\nlet tableName = \"\";\n//const providedApiKey = msg.payload.api_key;\n//const API_KEY = \"zaCELgL.0imfnc8mVLWwsAawjYr4Rx-Af50DDqtlx\";\nconst DEFAULT_COUNT = 10;\nconst {\n    api_key,\n    method,\n    count = DEFAULT_COUNT\n} = requestBody;\n\n// if (api_key != API_KEY) {\n//     msg.payload = {\n//         \"Error\": true,\n//         \"Description\": \"Invalid API Key\"\n//     };\n//     msg.statusCode = 200;\n//     return msg;\n// } \n\nswitch (calledMethod) {\n    case \"anomalyHistory\":\n        tableName = \"litmus.dbo.anomalyHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi17\":\n        tableName = \"litmus.dbo.avi17\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi1718\":\n        tableName = \"litmus.dbo.avi1718\";\n        break;  // Prevent fall-through with a break statement\n    case \"avi999\":\n        tableName = \"litmus.dbo.avi999\";\n        break;  // Prevent fall-through with a break statement\n    case \"downtimeHistory\":\n        tableName = \"litmus.dbo.downtimeHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"enigparam\":\n        tableName = \"litmus.dbo.enigparam\";\n        break;  // Prevent fall-through with a break statement\n    case \"filedrop\":\n        tableName = \"litmus.dbo.filedrop\";\n        break;  // Prevent fall-through with a break statement\n    case \"incident\":\n        tableName = \"litmus.dbo.incident\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentMonitor\":\n        tableName = \"litmus.dbo.incident_monitor\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentSop\":\n        tableName = \"litmus.dbo.incident_sop\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentTeam\":\n        tableName = \"litmus.dbo.incident_team\";\n        break;  // Prevent fall-through with a break statement\n    case \"incidentUser\":\n        tableName = \"litmus.dbo.incident_user\";\n        break;  // Prevent fall-through with a break statement\n    case \"jimiiotDevices\":\n        tableName = \"litmus.dbo.jimiiotDevices\";\n        break;  // Prevent fall-through with a break statement\n    case \"MLTrain\":\n        tableName = \"litmus.dbo.MLTrain\";\n        break;  // Prevent fall-through with a break statement\n    case \"modelFeature\":\n        tableName = \"litmus.dbo.modelfeature\";\n        break;  // Prevent fall-through with a break statement\n    case \"pcb_enig\":\n        tableName = \"litmus.dbo.pcb_enig\";\n        break;  // Prevent fall-through with a break statement\n    case \"pcb_thickness\":\n        tableName = \"litmus.dbo.pcb_thickness\";\n        break;  // Prevent fall-through with a break statement\n    case \"reasonCodes\":\n        tableName = \"litmus.dbo.reasonCodes\";\n        break;  // Prevent fall-through with a break statement\n    case \"scrapCodes\":\n        tableName = \"litmus.dbo.scrapCodes\";\n        break;  // Prevent fall-through with a break statement\n    case \"scrapHistory\":\n        tableName = \"litmus.dbo.scrapHistory\";\n        break;  // Prevent fall-through with a break statement\n    case \"spc\":\n        tableName = \"litmus.dbo.spc\";\n        break;  // Prevent fall-through with a break statement\n    case \"trackAsset\":\n        tableName = \"litmus.dbo.track_asset\";\n        break;  // Prevent fall-through with a break statement\n    default:\n        // Handle unknown method\n        msg.payload = {\n            error: true,\n            message: \"Invalid 'method' specified in the request.\"\n        };\n        msg.statusCode = 400; // Bad Request HTTP status code\n        return msg; // Stop execution and return error message\n}\n\n\n\nmsg.query2 = `SELECT TOP ${count} * FROM ${tableName}`;\n\n// If dateFrom and dateTo are provided and applicable, add a WHERE clause\n/*if (dateFrom && dateTo) {\n    // You should also ensure that dateFrom and dateTo are in the correct format\n    // and sanitized to prevent SQL injection\n    sqlQuery += ` WHERE Date BETWEEN '${dateFrom}' AND '${dateTo}' `;\n}*/\nmsg.statusCode = 200;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 580,
        "wires": [
            [
                "da64a4ebfa5b2aef",
                "5944c057456af3f9",
                "df34dfb2cfa6bef6"
            ]
        ]
    },
    {
        "id": "8ee9d06ae4b0bb33",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Unauthorized",
        "statusCode": "401",
        "headers": {},
        "x": 1670,
        "y": 100,
        "wires": []
    },
    {
        "id": "0fde76f0f98315a9",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Retrieve user credentials",
        "func": "msg.method = msg.payload.method;\nmsg.query = `SELECT password FROM litmus.dbo.api_user WHERE username = @username`;\nmsg.params = [\n    { name: 'username', type: 'VarChar', value: msg.credentials.username }\n];\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 400,
        "wires": [
            [
                "3f98daaf13bd9731",
                "ecf8c44443b7d797"
            ]
        ]
    },
    {
        "id": "f0fe8ca8f96589a2",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Bad Request",
        "statusCode": "400",
        "headers": {},
        "x": 1670,
        "y": 260,
        "wires": []
    },
    {
        "id": "7509b373f27c49df",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "400 Bad Request",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 400,\n    \"message\": \"Bad Request.\",\n    \"description\": \"The request cannot be processed due to malformed syntax. Please check the request format and parameters.\",\n    \"errors\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email is invalid.\"\n      },\n      {\n        \"field\": \"password\",\n        \"message\": \"Password must be at least 8 characters long.\"\n      }\n    ],\n    \"type\": \"INVALID_REQUEST_SYNTAX\",\n    \"documentation_url\": \"https://yourapi.com/docs/errors#400\"\n  }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1730,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "137b9f96b4c03b0d",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Too Many Requests",
        "statusCode": "429",
        "headers": {},
        "x": 1120,
        "y": 720,
        "wires": []
    },
    {
        "id": "ac9fd088939df164",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Rate limit",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 429,\n    \"message\": \"Too Many Requests.\",\n    \"description\": \"You have exceeded the request limit for this API. Please wait before sending more requests.\",\n    \"retry_after_seconds\": 3600\n  }\n}\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 720,
        "wires": [
            [
                "137b9f96b4c03b0d"
            ]
        ]
    },
    {
        "id": "9df8b6cd4216071f",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "function 13",
        "func": "// Assume `msg.payload` contains the error details or user input.\nlet responseBody;\nlet statusCode;\n\n// Check for different error conditions and set the status code and response body accordingly\nif (msg.payload.errorType === \"bad_request\") {\n    statusCode = 400;\n    responseBody = {\n        error: {\n            code: 400,\n            message: \"Bad Request\",\n            description: \"The server could not understand the request due to invalid syntax.\"\n        }\n    };\n} else if (msg.payload.errorType === \"unauthorized\") {\n    statusCode = 401;\n    responseBody = {\n        error: {\n            code: 401,\n            message: \"Unauthorized\",\n            description: \"Authentication is required and has failed or has not yet been provided.\"\n        }\n    };\n} else if (msg.payload.errorType === \"forbidden\") {\n    statusCode = 403;\n    responseBody = {\n        error: {\n            code: 403,\n            message: \"Forbidden\",\n            description: \"You do not have the necessary permissions to access this resource.\"\n        }\n    };\n} else {\n    // Default to internal server error\n    statusCode = 500;\n    responseBody = {\n        error: {\n            code: 500,\n            message: \"Internal Server Error\",\n            description: \"The server has encountered a situation it doesn't know how to handle.\"\n        }\n    };\n}\n\n// Set the status code and payload for the response\nmsg.statusCode = statusCode;\nmsg.payload = responseBody;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1710,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "aa85b13a4fc115c7",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 46",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1440,
        "y": 460,
        "wires": []
    },
    {
        "id": "82e1b18f1aa5a516",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "400",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 260,
        "wires": [
            [
                "f0fe8ca8f96589a2"
            ]
        ]
    },
    {
        "id": "3ed5748d75ca4f57",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "401",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 100,
        "wires": [
            [
                "8ee9d06ae4b0bb33"
            ]
        ]
    },
    {
        "id": "5e126690535e5fc6",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 47",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1520,
        "y": 360,
        "wires": []
    },
    {
        "id": "0d103c5a507a5326",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "function 14",
        "func": "// This function assumes that the auth headers are basic auth.\n// Extract the base64 encoded string from the headers.\nconst authHeader = msg.req.headers.authorization;\n\n// If no auth header is present, return a 401 Unauthorized error.\nif (!authHeader) {\n    msg.statusCode = 401;\n    msg.payload = {\n        error: \"Unauthorized\",\n        message: \"No authentication headers provided.\"\n    };\n    return [null, msg]; // The first output is null to stop the flow\n}\n\n// If the authHeader is present, decode it to get the username\nconst base64Credentials = authHeader.split(' ')[1];\nconst credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');\nconst [username, password] = credentials.split(':');\n\n// Now you would typically query your database to check if the username exists.\n// Since we can't perform asynchronous operations directly here,\n// we'll set the username on the message object and use a subsequent MSSQL node to query the database.\nmsg.username = username;\n\n// Pass the message to the next node (MSSQL node) to query the database.\n// We'll handle the result of that query in a different function node.\nreturn [msg, null]; // The second output is null because we don't want to return a response yet.\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1710,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "9bad93786ad8e400",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "403",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 180,
        "wires": [
            [
                "d7d27648899cfc9e"
            ]
        ]
    },
    {
        "id": "d7d27648899cfc9e",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Forbidden",
        "statusCode": "403",
        "headers": {},
        "x": 1660,
        "y": 180,
        "wires": []
    },
    {
        "id": "3210c5ac1f589c9a",
        "type": "function",
        "z": "0a31cc0a49282f6b",
        "name": "Authentication check",
        "func": "// Function node code for \"Authentication check\"\n// Extract the authorization header from the request.\nconst authHeader = msg.req.headers.authorization;\n\n// If the authorization header is missing, set the response status code to 401 Unauthorized.\nif (!authHeader) {\n    msg.statusCode = 401;\n    msg.payload = {\n        error: \"Unauthorized\",\n        message: \"Authentication information is missing or invalid.\"\n    };\n    node.status({fill:\"red\", shape:\"ring\", text:\"Unauthorized\"});\n    return msg; // Output to HTTP response node with 401 status code.\n} else {\n    msg.statusCode = 200;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 320,
        "wires": [
            [
                "455d603c43417cd1",
                "d8d9bc38e2e35736",
                "818e0ceff69b95a4"
            ]
        ]
    },
    {
        "id": "96ae9b94358320cc",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Unauthorized",
        "statusCode": "401",
        "headers": {},
        "x": 690,
        "y": 280,
        "wires": []
    },
    {
        "id": "455d603c43417cd1",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "401",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 530,
        "y": 260,
        "wires": [
            [
                "96ae9b94358320cc",
                "348f24851971c864"
            ]
        ]
    },
    {
        "id": "d8d9bc38e2e35736",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 530,
        "y": 380,
        "wires": [
            [
                "b0c784a282211e58",
                "0b8ca64b8063ae0e"
            ]
        ]
    },
    {
        "id": "9bf0d62983c4e13e",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "403",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 220,
        "wires": [
            [
                "f4a9a3db39601c1d"
            ]
        ]
    },
    {
        "id": "f4a9a3db39601c1d",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Bad Request",
        "statusCode": "400",
        "headers": {},
        "x": 1670,
        "y": 220,
        "wires": []
    },
    {
        "id": "d050fd95399853dc",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Internal Server Error",
        "statusCode": "500",
        "headers": {},
        "x": 1700,
        "y": 60,
        "wires": []
    },
    {
        "id": "fa56fbb8486594ea",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "500",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 60,
        "wires": [
            [
                "d050fd95399853dc"
            ]
        ]
    },
    {
        "id": "b6427c6169468c87",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1490,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "818e0ceff69b95a4",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 48",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 540,
        "y": 320,
        "wires": []
    },
    {
        "id": "0b8ca64b8063ae0e",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 49",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 360,
        "wires": []
    },
    {
        "id": "348f24851971c864",
        "type": "debug",
        "z": "0a31cc0a49282f6b",
        "name": "debug 50",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 240,
        "wires": []
    },
    {
        "id": "121ed7651419dbf5",
        "type": "change",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 560,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "58c128caa6f53cd6",
        "type": "template",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "This is the payload: {{payload}} !",
        "output": "str",
        "x": 540,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "5944c057456af3f9",
        "type": "switch",
        "z": "0a31cc0a49282f6b",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "401",
                "vt": "num"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1110,
        "y": 660,
        "wires": [
            [
                "6c0fb1e25b6ad3c3"
            ]
        ]
    },
    {
        "id": "6c0fb1e25b6ad3c3",
        "type": "http response",
        "z": "0a31cc0a49282f6b",
        "name": "Unauthorized",
        "statusCode": "401",
        "headers": {},
        "x": 1290,
        "y": 660,
        "wires": []
    },
    {
        "id": "c9f7b011dccb3383",
        "type": "comment",
        "z": "a215c175be6747f4",
        "name": "Create new account with hashed password",
        "info": "",
        "x": 180,
        "y": 60,
        "wires": []
    },
    {
        "id": "de8ddd6de7d7fb6d",
        "type": "function",
        "z": "a215c175be6747f4",
        "name": "Password Hashing",
        "func": "const bcrypt = global.get('bcrypt'); // assuming bcrypt is in global context\nconst saltRounds = 10;\n\nbcrypt.hash(msg.payload.password, saltRounds, function(err, hash) {\n    if (err) {\n        node.error('Error hashing password', err);\n        msg.payload = { error: \"Error hashing password\" };\n        return msg; // We can handle the error in the flow if needed\n    } else {\n        msg.payload = {\n            username: msg.payload.username,\n            password: hash\n        };\n        node.send(msg); // Continue with the flow to the next node\n    }\n});\n// Since bcrypt is asynchronous, we use node.send to handle the next steps of the flow\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 140,
        "wires": [
            [
                "bb32b8c03e951b37"
            ]
        ]
    },
    {
        "id": "da34d3ecbfa032eb",
        "type": "debug",
        "z": "a215c175be6747f4",
        "name": "debug 25",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 880,
        "y": 100,
        "wires": []
    },
    {
        "id": "eb8f2b7a1e3b778b",
        "type": "http in",
        "z": "a215c175be6747f4",
        "name": "",
        "url": "/api/createUser",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 120,
        "y": 140,
        "wires": [
            [
                "de8ddd6de7d7fb6d"
            ]
        ]
    },
    {
        "id": "82f42f962ce81839",
        "type": "MSSQL",
        "z": "a215c175be6747f4",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "INSERT INTO litmus.dbo.api_user (username, password) VALUES (@username, @password)\r\n",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "params",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 700,
        "y": 140,
        "wires": [
            [
                "da34d3ecbfa032eb",
                "fc8b5f9581964c81"
            ]
        ]
    },
    {
        "id": "bb32b8c03e951b37",
        "type": "function",
        "z": "a215c175be6747f4",
        "name": "query",
        "func": "msg.topic = 'INSERT INTO litmus.dbo.api_user (username, password) VALUES (@username, @password)';\nmsg.params = [\n    { name: 'Username', type: 'Varchar', value: msg.payload.username},\n    { name: 'Password', type: 'Varchar', value: msg.payload.password}\n];\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 140,
        "wires": [
            [
                "82f42f962ce81839"
            ]
        ]
    },
    {
        "id": "fc8b5f9581964c81",
        "type": "http response",
        "z": "a215c175be6747f4",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 880,
        "y": 160,
        "wires": []
    },
    {
        "id": "f510be3658d193fa",
        "type": "comment",
        "z": "07faf086ce88aab0",
        "name": "Count downtime instance for Machine 1 for every hour",
        "info": "",
        "x": 260,
        "y": 60,
        "wires": []
    },
    {
        "id": "5cab23cdf12c2a93",
        "type": "e-mail",
        "z": "07faf086ce88aab0",
        "server": "smtp.gmail.com",
        "port": "465",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": true,
        "tls": true,
        "name": "tp068144@mail.apu.edu.my",
        "dname": "Recipient",
        "x": 840,
        "y": 260,
        "wires": []
    },
    {
        "id": "bd1ab2e72de588b8",
        "type": "MSSQL",
        "z": "07faf086ce88aab0",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "SELECT \r\n  COUNT(*) AS TotalDowntimeInstances\r\nFROM \r\n  litmus.dbo.downtimeHistory\r\nWHERE \r\n  asset = 'Machine 1' AND\r\n  startTime >= DATEADD(hour, DATEDIFF(hour, 0, GETDATE()) - 1, 0) AND\r\n  startTime < DATEADD(hour, DATEDIFF(hour, 0, GETDATE()), 0)\r\n",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "payload",
        "queryOptType": "editor",
        "paramsOpt": "queryParams",
        "paramsOptType": "none",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 400,
        "y": 260,
        "wires": [
            [
                "2411cb6ddca2146b",
                "a52e7a26b6e6a155"
            ]
        ]
    },
    {
        "id": "2411cb6ddca2146b",
        "type": "debug",
        "z": "07faf086ce88aab0",
        "name": "debug 24",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 220,
        "wires": []
    },
    {
        "id": "401f99531d970dd4",
        "type": "inject",
        "z": "07faf086ce88aab0",
        "name": "Recurring injection",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 260,
        "wires": [
            [
                "bd1ab2e72de588b8"
            ]
        ]
    },
    {
        "id": "a52e7a26b6e6a155",
        "type": "function",
        "z": "07faf086ce88aab0",
        "name": "Email subject and body",
        "func": "msg.topic = \"Downtime Report for Machine 1\"; // This will be the email subject\nmsg.payload = \"Total downtime instances in the last hour: \" + msg.payload[0].TotalDowntimeInstances; // Assuming msg.payload contains the downtime instances count\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 260,
        "wires": [
            [
                "5cab23cdf12c2a93"
            ]
        ]
    },
    {
        "id": "aad236e956cc5704",
        "type": "http in",
        "z": "74d4b18460046b49",
        "name": "",
        "url": "/api/litmus/live/inventory",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 340,
        "wires": [
            [
                "4c9b1129453fec1f",
                "98e9c623850c0206"
            ]
        ]
    },
    {
        "id": "4c9b1129453fec1f",
        "type": "debug",
        "z": "74d4b18460046b49",
        "name": "debug HTTP IN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 300,
        "wires": []
    },
    {
        "id": "98e9c623850c0206",
        "type": "rate-limiter",
        "z": "74d4b18460046b49",
        "delay_action": "ratelimit",
        "rate": "12",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 460,
        "y": 340,
        "wires": [
            [
                "6601374ce20a2364",
                "3607c9db5d299f14"
            ],
            [
                "897bed232fe56942"
            ]
        ]
    },
    {
        "id": "897bed232fe56942",
        "type": "function",
        "z": "74d4b18460046b49",
        "name": "Rate limit",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 429,\n    \"message\": \"Too Many Requests.\",\n    \"description\": \"You have exceeded the request limit for this API. Please wait before sending more requests.\",\n    \"retry_after_seconds\": 60\n  }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 400,
        "wires": [
            [
                "80f9ec961ff508a1"
            ]
        ]
    },
    {
        "id": "6601374ce20a2364",
        "type": "debug",
        "z": "74d4b18460046b49",
        "name": "debug 52",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 300,
        "wires": []
    },
    {
        "id": "3607c9db5d299f14",
        "type": "function",
        "z": "74d4b18460046b49",
        "name": "Method validation",
        "func": "// Function node to validate 'method' attribute\nlet validMethods = ['getDowntimeHistory', 'getScrapHistory', 'getIncidentUser', 'getScrapCodes', 'getPCBEnig', 'updateInventory']; // Add all your valid methods here\n\n// Check if the method is null or not in the list of valid methods\nif (msg.req.body.method === null || validMethods.indexOf(msg.req.body.method) === -1) {\n    // Set error message and stop the flow (you might want to send this to an HTTP response or similar)\n    msg.payload = { error: \"Invalid or missing 'method' parameter.\" };\n    msg.statusCode = 400;\n    return msg; // Stops the flow if you're using a Switch or Function node to route messages based on their content\n} else {\n    // Continue with the flow if the method is valid\n    msg.statusCode = 200;\n    return msg;\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 340,
        "wires": [
            [
                "3fee7c5a23ddc4ac",
                "35ae48437d89a9b2"
            ]
        ]
    },
    {
        "id": "80f9ec961ff508a1",
        "type": "http response",
        "z": "74d4b18460046b49",
        "name": "Too Many Requests",
        "statusCode": "429",
        "headers": {},
        "x": 880,
        "y": 400,
        "wires": []
    },
    {
        "id": "3fee7c5a23ddc4ac",
        "type": "debug",
        "z": "74d4b18460046b49",
        "name": "debug method val",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1110,
        "y": 300,
        "wires": []
    },
    {
        "id": "35ae48437d89a9b2",
        "type": "switch",
        "z": "74d4b18460046b49",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "400",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1110,
        "y": 340,
        "wires": [
            [
                "f31589f87987df6c"
            ],
            [
                "c455835a14fe173d"
            ]
        ]
    },
    {
        "id": "f31589f87987df6c",
        "type": "switch",
        "z": "74d4b18460046b49",
        "name": "Switch",
        "property": "req.body.method",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "updateInventory",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1290,
        "y": 320,
        "wires": [
            [
                "3ed954752107be04"
            ]
        ]
    },
    {
        "id": "c455835a14fe173d",
        "type": "http response",
        "z": "74d4b18460046b49",
        "name": "",
        "statusCode": "400",
        "headers": {},
        "x": 1260,
        "y": 400,
        "wires": []
    },
    {
        "id": "3ed954752107be04",
        "type": "function",
        "z": "74d4b18460046b49",
        "name": "Configuration Object v2 (Inventory)",
        "func": "// Function node to construct batch SQL insert statements\nconst items = msg.payload.params;\nlet values = items.map(item => {\n    // Assuming 'item_id', 'item_name', and 'quantity' are strings; adapt as necessary\n    return `('${item.item_id}', '${item.item_name}', ${item.quantity})`;\n}).join(',');\n\nmsg.topic = `\n    INSERT INTO litmus.dbo.Inventory (item_id, item_name, quantity)\n    VALUES ${values};\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 320,
        "wires": [
            [
                "7f0df222706f5522"
            ]
        ]
    },
    {
        "id": "7f0df222706f5522",
        "type": "MSSQL",
        "z": "74d4b18460046b49",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "MSSQL-PLUS-2",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 1800,
        "y": 320,
        "wires": [
            [
                "aed21114e3c0c72d",
                "d3feb3fcf641bfc5"
            ]
        ]
    },
    {
        "id": "aed21114e3c0c72d",
        "type": "debug",
        "z": "74d4b18460046b49",
        "name": "debug MSSQL",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2040,
        "y": 260,
        "wires": []
    },
    {
        "id": "d3feb3fcf641bfc5",
        "type": "function",
        "z": "74d4b18460046b49",
        "name": "function 19",
        "func": "// Function node to handle SQL errors and set HTTP response\nif (msg.error && msg.error.code === \"EREQUEST\") {\n    // Check if the error message contains 'duplicate key'\n    if (msg.error.message.includes('duplicate key')) {\n        msg.statusCode = 409; // HTTP 409 Conflict\n        msg.payload = {\n            error: \"Duplicate key error: cannot insert item with the same ID.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    } else {\n        // Handle other SQL errors here if necessary\n        msg.statusCode = 500;\n        msg.payload = {\n            error: \"A database error occurred.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    }\n} else {\n    msg.statusCode = 200;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 320,
        "wires": [
            [
                "a77c794dfc40632f"
            ]
        ]
    },
    {
        "id": "e9828fa2e4db8391",
        "type": "catch",
        "z": "74d4b18460046b49",
        "name": "",
        "scope": [
            "7f0df222706f5522"
        ],
        "uncaught": false,
        "x": 1810,
        "y": 280,
        "wires": [
            [
                "d3feb3fcf641bfc5"
            ]
        ]
    },
    {
        "id": "a77c794dfc40632f",
        "type": "switch",
        "z": "74d4b18460046b49",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "409",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 2210,
        "y": 320,
        "wires": [
            [
                "8be38e238f5ea822"
            ],
            [
                "43cc821dfe197a37"
            ]
        ]
    },
    {
        "id": "8be38e238f5ea822",
        "type": "http response",
        "z": "74d4b18460046b49",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 2380,
        "y": 300,
        "wires": []
    },
    {
        "id": "43cc821dfe197a37",
        "type": "http response",
        "z": "74d4b18460046b49",
        "name": "",
        "statusCode": "409",
        "headers": {},
        "x": 2380,
        "y": 380,
        "wires": []
    },
    {
        "id": "1feb750e511288b8",
        "type": "file in",
        "z": "cabe4ab3486d8daf",
        "name": "",
        "filename": "/home/sebastian/Desktop/pcb_failure_analysis.csv",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 590,
        "y": 260,
        "wires": [
            [
                "d42eaa86.c12c18"
            ]
        ]
    },
    {
        "id": "d92c65a4.566478",
        "type": "inject",
        "z": "cabe4ab3486d8daf",
        "d": true,
        "name": "Inject",
        "props": [],
        "repeat": "3",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 130,
        "y": 260,
        "wires": [
            [
                "1feb750e511288b8"
            ]
        ]
    },
    {
        "id": "d42eaa86.c12c18",
        "type": "csv",
        "z": "cabe4ab3486d8daf",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": false,
        "x": 870,
        "y": 260,
        "wires": [
            [
                "494beb505bdce40c",
                "806a2e7eefafddd4"
            ]
        ]
    },
    {
        "id": "8fa3242c05340fd2",
        "type": "debug",
        "z": "cabe4ab3486d8daf",
        "name": "msg.payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 220,
        "wires": []
    },
    {
        "id": "37df3efc602aad3e",
        "type": "MSSQL",
        "z": "cabe4ab3486d8daf",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "queryParams",
        "paramsOptType": "none",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 1240,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "806a2e7eefafddd4",
        "type": "function",
        "z": "cabe4ab3486d8daf",
        "name": "Data insertion",
        "func": "// Initialize or increment the index\nlet index = flow.get('currentIndex') || 0; // Ensure it's set to 0 if undefined\n\n// Get the parsed CSV data array from the payload\nlet dataArray = flow.get('csvData') || msg.payload; // It's better to get this from flow if already stored\n\n// Check if there is data at the current index\nif (index < dataArray.length) {\n    // Get the current row to insert\n    let row = dataArray[index];\n\n    // Construct the SQL INSERT statement\n    const tableName = \"litmus.dbo.PCBFailureAnalysis\";\n    let columns = Object.keys(row).join(\", \");\n    let values = Object.values(row).map(value =>\n        typeof value === 'string' ? `'${value.replace(/'/g, \"''\")}'` : value\n    ).join(\", \");\n\n    // Do not include the ActualInsertionTime column in the INSERT statement\n    let sqlQuery = `INSERT INTO ${tableName} (${columns}) VALUES (${values});`;\n\n    // Prepare the message for the MSSQL node\n    msg.topic = sqlQuery;\n\n    // Increment the index for the next row\n    flow.set('currentIndex', index + 1);\n\n    // Return the message object to continue the flow\n    return msg;\n} else {\n    // Reset the index if you have reached the end of the array\n    flow.set('currentIndex', 0);\n\n    // Send a message that you've reached the end of the data\n    node.warn(\"End of CSV data reached, looping back to the start.\");\n    return null; // You can choose to return null to stop the flow\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 260,
        "wires": [
            [
                "8fa3242c05340fd2",
                "37df3efc602aad3e"
            ]
        ]
    },
    {
        "id": "494beb505bdce40c",
        "type": "debug",
        "z": "cabe4ab3486d8daf",
        "name": "msg.payload",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 220,
        "wires": []
    },
    {
        "id": "ef8b695dc76e14d6",
        "type": "inject",
        "z": "cabe4ab3486d8daf",
        "name": "Reset count",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 340,
        "wires": [
            [
                "555be4e020b6b810"
            ]
        ]
    },
    {
        "id": "555be4e020b6b810",
        "type": "function",
        "z": "cabe4ab3486d8daf",
        "name": "Index reset",
        "func": "// This code goes in Function Node 23\nflow.set('currentIndex', 0); // Reset the index\n//return msg; // You can return the message if you want to trigger downstream nodes or you could return null to do nothing further\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 340,
        "wires": [
            [
                "1feb750e511288b8"
            ]
        ]
    },
    {
        "id": "ae6318ea765abeec",
        "type": "http in",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "url": "/api/litmus/live",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 280,
        "wires": [
            [
                "af618c1bd4322c4b",
                "7cd93d299074e8c1"
            ]
        ]
    },
    {
        "id": "19d333fde6be4cc0",
        "type": "comment",
        "z": "d516f4c69dd3bbfe",
        "name": "Generic endpoint (Payload Basic Auth)",
        "info": "",
        "x": 190,
        "y": 60,
        "wires": []
    },
    {
        "id": "9d6d0581a2257046",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 3080,
        "y": 460,
        "wires": []
    },
    {
        "id": "54346154534ab1dd",
        "type": "MSSQL",
        "z": "d516f4c69dd3bbfe",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "MSSQL-PLUS-2",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 2580,
        "y": 440,
        "wires": [
            [
                "c5e22f80e7ba42e3",
                "6ee68dbd9ec725ef"
            ]
        ]
    },
    {
        "id": "9c673dee549b9783",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug MSSQL",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 340,
        "wires": []
    },
    {
        "id": "4c3a45deb7e3536a",
        "type": "MSSQL",
        "z": "d516f4c69dd3bbfe",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "SELECT PasswordHash FROM litmus.dbo.api_user WHERE Username = @username",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "parameters",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 840,
        "y": 380,
        "wires": [
            [
                "9c673dee549b9783",
                "cdc661b2c1bc477d"
            ]
        ]
    },
    {
        "id": "398a169c9d26824b",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Retrieve user credentials",
        "func": "msg.method = msg.payload.method;\nmsg.query = `SELECT password FROM litmus.dbo.users WHERE username = @username`;\nmsg.params = [\n    { name: 'username', type: 'VarChar', value: msg.credentials.username }\n];\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "92c7d44cd8371b5c",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "400 Bad Request",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 400,\n    \"message\": \"Bad Request.\",\n    \"description\": \"The request cannot be processed due to malformed syntax. Please check the request format and parameters.\",\n    \"errors\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email is invalid.\"\n      },\n      {\n        \"field\": \"password\",\n        \"message\": \"Password must be at least 8 characters long.\"\n      }\n    ],\n    \"type\": \"INVALID_REQUEST_SYNTAX\",\n    \"documentation_url\": \"https://yourapi.com/docs/errors#400\"\n  }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "272e08d7d7543cf6",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "function 21",
        "func": "// Assume `msg.payload` contains the error details or user input.\nlet responseBody;\nlet statusCode;\n\n// Check for different error conditions and set the status code and response body accordingly\nif (msg.payload.errorType === \"bad_request\") {\n    statusCode = 400;\n    responseBody = {\n        error: {\n            code: 400,\n            message: \"Bad Request\",\n            description: \"The server could not understand the request due to invalid syntax.\"\n        }\n    };\n} else if (msg.payload.errorType === \"unauthorized\") {\n    statusCode = 401;\n    responseBody = {\n        error: {\n            code: 401,\n            message: \"Unauthorized\",\n            description: \"Authentication is required and has failed or has not yet been provided.\"\n        }\n    };\n} else if (msg.payload.errorType === \"forbidden\") {\n    statusCode = 403;\n    responseBody = {\n        error: {\n            code: 403,\n            message: \"Forbidden\",\n            description: \"You do not have the necessary permissions to access this resource.\"\n        }\n    };\n} else {\n    // Default to internal server error\n    statusCode = 500;\n    responseBody = {\n        error: {\n            code: 500,\n            message: \"Internal Server Error\",\n            description: \"The server has encountered a situation it doesn't know how to handle.\"\n        }\n    };\n}\n\n// Set the status code and payload for the response\nmsg.statusCode = statusCode;\nmsg.payload = responseBody;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "c5e22f80e7ba42e3",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug MSSQL",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2780,
        "y": 380,
        "wires": []
    },
    {
        "id": "af618c1bd4322c4b",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug HTTP IN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 280,
        "y": 340,
        "wires": []
    },
    {
        "id": "3958cb1b053b07b0",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Main function (imported)",
        "func": "const requestBody = msg.payload;\nlet tableName = \"\";\nconst DEFAULT_COUNT = 10;\nlet query = \"\";\nlet queryParams = [];\n\nconst {\n    method,\n    params,\n    rows = DEFAULT_COUNT\n} = requestBody;\n\nswitch (method) {\n    case \"getDowntimeHistory\":\n        tableName = \"litmus.dbo.downtimeHistory\";\n        query = `SELECT TOP ${rows} * FROM ${tableName} WHERE startTime >= @startDate AND endTime < @endDate AND line = @line AND asset = @asset AND scrapCode_text = @scrapCode_text`;\n        queryParams = [\n            { name: 'startDate', value: params.startTime, type: 'VarChar' },\n            { name: 'endDate', value: params.endTime, type: 'VarChar' },\n            { name: 'line', value: params.line, type: 'VarChar' },\n            { name: 'asset', value: params.asset, type: 'VarChar' },\n            { name: 'reasonCode_L1_text', value: params.reasonCode_L1_text, type: 'VarChar' },\n            { name: 'reasonCode_L2_text', value: params.reasonCode_L2_text, type: 'VarChar' }\n        ];\n        break;\n        \n    //done\n     case \"getScrapHistory\":\n        tableName = \"litmus.dbo.scrapHistory\";\n        query = `SELECT TOP ${rows} * FROM ${tableName} WHERE scrapTime BETWEEN @startDate AND @endDate AND line = @line AND asset = @asset AND scrapCode_text = @scrapCode_text`;\n        queryParams = [\n            { name: 'startDate', value: params.startDate, type: 'VarChar' },\n            { name: 'endDate', value: params.endDate, type: 'VarChar' },\n            { name: 'line', value: params.line, type: 'VarChar' },\n            { name: 'asset', value: params.asset, type: 'VarChar' },\n            { name: 'scrapCode_text', value: params.scrapCode_text, type: 'VarChar' }\n        ];\n        break;  // Prevent fall-through with a break statement\n    // case \"incidentTeam\":\n    //     tableName = \"litmus.dbo.incident_team\";\n    //     query = `SELECT TOP ${rows} * FROM ${tableName} WHERE scrapTime BETWEEN @startDate AND @endDate AND line = @line AND asset = @asset AND scrapCode_text = @scrapCode_text`;\n    //     queryParams = [\n    //         { name: 'startDate', value: params.startDate, type: 'VarChar' },\n    //         { name: 'endDate', value: params.endDate, type: 'VarChar' },\n    //         { name: 'line', value: params.line, type: 'VarChar' },\n    //         { name: 'asset', value: params.asset, type: 'VarChar' },\n    //         { name: 'scrapCode_text', value: params.scrapCode_text, type: 'VarChar' }\n    //     ];\n    //     break;  // Prevent fall-through with a break statement\n    // case \"incidentUser\":\n    //     tableName = \"litmus.dbo.incident_user\";\n    //     break;  // Prevent fall-through with a break statement\n    // case \"reasonCodes\":\n    //     tableName = \"litmus.dbo.reasonCodes\";\n    //     break;  // Prevent fall-through with a break statement\n    // case \"scrapCodes\":\n    //     tableName = \"litmus.dbo.scrapCodes\";\n    //     break;  // Prevent fall-through with a break statement\n   \n   \n    default:\n        // Handle unknown method\n        msg.payload = {\n            error: true,\n            message: \"Invalid 'method' specified in the request.\"\n        };\n        msg.statusCode = 400; // Bad Request HTTP status code\n        return msg; // Stop execution and return error message\n}\n\nmsg.topic = query;\nmsg.payload = queryParams;\n\n\n// Continue with the flow\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "cdc661b2c1bc477d",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Credentials Verification ",
        "func": "if (msg.authenticationMethod === 'apiKey') {\n    // Assuming the database query checks for existence and you use the result to validate\n    let apiKeyExists = msg.payload[0]?.keyCount > 0; // Adjust based on your actual payload structure and query result\n\n    if (apiKeyExists) {\n        msg.payload = { success: true, message: \"API key authentication successful.\" };\n        msg.statusCode = 200;\n    } else {\n        msg.payload = { success: false, message: \"Invalid API key.\" };\n        msg.statusCode = 401; // Unauthorized\n    }\n} else if (msg.authenticationMethod === 'usernamePassword') {\n    // Username/Password Authentication\n    // Assuming you have fetched the stored password from the database for the given username\n    let storedPassword = msg.payload[0]?.password; // Adjust based on your actual payload structure\n    let providedPassword = msg.providedPassword;\n\n    // Compare the provided password against the stored password\n    // This example assumes plain text comparison, consider using hashed passwords in a real application\n    if (providedPassword && providedPassword === storedPassword) {\n        msg.payload = { success: true, message: \"Username and password authentication successful.\" };\n        msg.statusCode = 200;\n        return msg;\n    } else {\n        msg.payload = { success: false, message: \"Authentication failed.\" };\n        msg.statusCode = 401; // Unauthorized\n    }\n} else {\n    // If the authentication method is not recognized or not provided correctly\n    msg.payload = { success: false, message: \"Unsupported authentication method.\" };\n    msg.statusCode = 400; // Bad Request\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 480,
        "wires": [
            [
                "00186838147fdb8e",
                "f2e451c39b384203"
            ]
        ]
    },
    {
        "id": "68cba47f671e81c5",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "function 22",
        "func": "let id = msg.payload.id;\n\n// Create an object for the parameters\n// It should match the expected format by the MSSQL-PLUS node\n//msg.payload = {}; // Clearing payload for MSSQL-PLUS to avoid conflicts\nmsg.parameters = [\n    {\n        name: \"id\",\n        value: id,\n        type: \"Int\"\n    }\n];\n\nmsg.topic = \"SELECT * FROM litmus.dbo.scrapHistory WHERE id = @id\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "540bc4cbebb94805",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object",
        "func": "// A configuration object that defines the expected parameters for each table.\nconst tableConfigs = {\n    scrapHistory: {\n        tableName: \"litmus.dbo.scrapHistory\",\n        validParams: ['startDate', 'endDate', 'line', 'asset', 'scrapCode_text']\n        // ... other table-specific configurations\n    },\n    downtimeHistory: {\n        tableName: \"litmus.dbo.downtimeHistory\",\n        validParams: ['startDate', 'endDate', 'machineID']\n        // ... other table-specific configurations\n    },\n    // ... configurations for other tables\n};\n\nconst requestBody = msg.payload;\nlet queryParams = [];\nlet conditions = [];\nlet queryBase = \"\";\nlet tableName = \"\";\nlet rows = requestBody.rows || 100;\n\n// Determine the table and parameters based on the method provided in the request\nconst tableConfig = tableConfigs[requestBody.method];\n\nif (tableConfig) {\n    tableName = tableConfig.tableName;\n    queryBase = `SELECT TOP ${rows} * FROM ${tableName}`;\n    // Iterate over the validParams and check if they have been provided in the request\n    tableConfig.validParams.forEach(param => {\n        if (requestBody.params[param]) {\n            conditions.push(`${param} = @${param}`);\n            queryParams.push({\n                name: param,\n                value: requestBody.params[param],\n                type: 'VarChar' // This should be set according to the actual data type of the field\n            });\n        }\n    });\n} else {\n    node.error(\"Invalid method provided\");\n    return null; // Stop the flow since we encountered an error\n}\n\n// Build the full SQL query\nlet sqlQuery = queryBase;\nif (conditions.length) {\n    sqlQuery += \" WHERE \" + conditions.join(\" AND \");\n}\n\nmsg.topic = sqlQuery;\nmsg.payload = queryParams;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "efeebc5a4940f70c",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (downtime History)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.downtimeHistory\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) { // Assuming an empty string is not a valid value\n        switch (param) {\n            case \"startDate\":\n                whereConditions.push(`startTime >= @startDate`);\n                queryParams.push({ name: 'startDate', value: value, type: 'VarChar' });\n                break;\n            case \"endDate\":\n                whereConditions.push(`endTime <= @endDate`);\n                queryParams.push({ name: 'endDate', value: value, type: 'VarChar' });\n                break;\n            case \"reasonCode_L1_text\":\n            case \"reasonCode_L2_text\":\n            case \"asset\":\n            case \"line\":\n                // Directly mapping other parameters to database columns\n                whereConditions.push(`${param} = @${param}`);\n                queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n                break;\n            // You can add more cases here if you have more parameters\n        }\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Append ORDER BY clause to sort by scrapTime in descending order\nqueryBase += \" ORDER BY startTime DESC\";\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 300,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "dc52ede7662d8ffc",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (scrap History)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.scrapHistory\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n        if (param === \"startDate\" || param === \"endDate\") {\n            const operator = param === \"startDate\" ? \">=\" : \"<=\";\n            whereConditions.push(`scrapTime ${operator} @${param}`);\n            queryParams.push({ name: param, value: value, type: 'VarChar' });\n        } else {\n            // For other parameters that directly map to database columns\n            whereConditions.push(`${param} = @${param}`);\n            queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n        }\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Append ORDER BY clause to sort by scrapTime in descending order\nqueryBase += \" ORDER BY scrapTime DESC\";\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2230,
        "y": 340,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "05dbf9621fa089ce",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (scrap Codes)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.scrapCodes\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n       // For other parameters that directly map to database columns\n        whereConditions.push(`${param} = @${param}`);\n        queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2230,
        "y": 420,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "158f2e8ae117d0bf",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (incident User)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.incident_user\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n       // For other parameters that directly map to database columns\n        whereConditions.push(`${param} = @${param}`);\n        queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2230,
        "y": 380,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "9793a193316218a7",
        "type": "switch",
        "z": "d516f4c69dd3bbfe",
        "name": "Switch",
        "property": "req.body.method",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "getDowntimeHistory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getScrapHistory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getIncidentUser",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getScrapCodes",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getPCBEnig",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "updateInventory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getPCBFA",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "prev"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 1950,
        "y": 360,
        "wires": [
            [
                "efeebc5a4940f70c"
            ],
            [
                "dc52ede7662d8ffc"
            ],
            [
                "158f2e8ae117d0bf"
            ],
            [
                "05dbf9621fa089ce"
            ],
            [
                "94e237d9f0a50340"
            ],
            [
                "6d467a3aab765585"
            ],
            [
                "a0d61685d959fc23"
            ],
            [
                "467f2345c93a5b4c"
            ]
        ]
    },
    {
        "id": "f2e451c39b384203",
        "type": "switch",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "401",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1350,
        "y": 400,
        "wires": [
            [
                "559a22454e7b9130"
            ],
            [
                "965272a6c4fc4762"
            ]
        ]
    },
    {
        "id": "965272a6c4fc4762",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "statusCode": "401",
        "headers": {},
        "x": 1560,
        "y": 420,
        "wires": []
    },
    {
        "id": "00186838147fdb8e",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug cred vad",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 340,
        "wires": []
    },
    {
        "id": "5cbf6098a84d4a8b",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "statusCode": "400",
        "headers": {},
        "x": 960,
        "y": 340,
        "wires": []
    },
    {
        "id": "89cd10f763cfca16",
        "type": "switch",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "400",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 810,
        "y": 340,
        "wires": [
            [
                "5cbf6098a84d4a8b"
            ]
        ]
    },
    {
        "id": "e8e15e5bea76b8c4",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Credentials Extraction ",
        "func": "let username = msg.payload.username;\nlet password = msg.payload.password;\n// Adjusted to consistently get the API key, ensuring we account for both direct payload and req.body\nlet apiKey = msg.payload.api_key || msg.req.body.api_key;\n\n// Determine the authentication method and set up accordingly\nif (apiKey) {\n    // For API key authentication\n    msg.authenticationMethod = 'apiKey';\n    msg.apiKey = apiKey;\n    // Adjusted for consistency in parameterization\n    msg.topic = `SELECT COUNT(apiKey) AS keyCount FROM litmus.dbo.api_key WHERE apiKey = @apiKey`;\n    msg.parameters = [\n        { name: \"apiKey\", value: msg.apiKey, type: \"VarChar\" }\n    ];\n} else if (username && password) {\n    // For username/password authentication\n    msg.authenticationMethod = 'usernamePassword';\n    // Ensure the query matches the parameterization style\n    msg.topic = 'SELECT password FROM litmus.dbo.users WHERE username = @username';\n    msg.parameters = [\n        { name: \"username\", value: username, type: \"VarChar\" }\n    ];\n    // Store provided password for comparison later\n    msg.providedPassword = password;\n} else {\n    // Neither method provided adequately\n    msg.payload = { success: false, message: \"Authentication requires either an API key or both username and password.\" };\n    msg.statusCode = 400; // Bad Request\n    return msg;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "89cd10f763cfca16",
                "4c3a45deb7e3536a",
                "3b75d0a8cdc2b636"
            ]
        ]
    },
    {
        "id": "559a22454e7b9130",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Method validation",
        "func": "// Function node to validate 'method' attribute\nlet validMethods = ['getDowntimeHistory', 'getScrapHistory', 'getIncidentUser', 'getScrapCodes', 'getPCBEnig', 'updateInventory', 'getPCBFA']; // Add all your valid methods here\n\n// Check if the method is null or not in the list of valid methods\nif (msg.req.body.method === null || validMethods.indexOf(msg.req.body.method) === -1) {\n    // Set error message and stop the flow (you might want to send this to an HTTP response or similar)\n    //msg.payload = { error: \"Invalid or missing 'method' parameter.\" };\n    msg.statusCode = 200;\n    return msg; // Stops the flow if you're using a Switch or Function node to route messages based on their content\n} else {\n    // Continue with the flow if the method is valid\n    msg.statusCode = 200;\n    return msg;\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 380,
        "wires": [
            [
                "b4206cb167cea507",
                "032480f20b2d8647"
            ]
        ]
    },
    {
        "id": "d82ebef4d035dc61",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "statusCode": "400",
        "headers": {},
        "x": 1920,
        "y": 440,
        "wires": []
    },
    {
        "id": "b4206cb167cea507",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug method val",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1770,
        "y": 340,
        "wires": []
    },
    {
        "id": "032480f20b2d8647",
        "type": "switch",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "400",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1770,
        "y": 380,
        "wires": [
            [
                "9793a193316218a7"
            ],
            [
                "d82ebef4d035dc61"
            ]
        ]
    },
    {
        "id": "6d467a3aab765585",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (Inventory)",
        "func": "// Function node to construct batch SQL insert statements\nconst items = msg.payload.params;\nlet values = items.map(item => {\n    // Assuming 'item_id', 'item_name', and 'quantity' are strings; adapt as necessary\n    return `('${item.item_id}', '${item.item_name}', ${item.quantity})`;\n}).join(',');\n\nmsg.topic = `\n    INSERT INTO litmus.dbo.Inventory (item_id, item_name, quantity)\n    VALUES ${values};\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2220,
        "y": 500,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "7cd93d299074e8c1",
        "type": "rate-limiter",
        "z": "d516f4c69dd3bbfe",
        "delay_action": "ratelimit",
        "rate": "60",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 320,
        "y": 380,
        "wires": [
            [
                "78c0ed2b995c9ed4",
                "e8e15e5bea76b8c4"
            ],
            [
                "43c933bb990b73ad"
            ]
        ]
    },
    {
        "id": "04592ae7c465f95b",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "Too Many Requests",
        "statusCode": "429",
        "headers": {},
        "x": 740,
        "y": 440,
        "wires": []
    },
    {
        "id": "43c933bb990b73ad",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Rate limit",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 429,\n    \"message\": \"Too Many Requests.\",\n    \"description\": \"You have exceeded the request limit for this API. Please wait before sending more requests.\",\n    \"retry_after_seconds\": 60\n  }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 440,
        "wires": [
            [
                "04592ae7c465f95b"
            ]
        ]
    },
    {
        "id": "78c0ed2b995c9ed4",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug 57",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 340,
        "wires": []
    },
    {
        "id": "94e237d9f0a50340",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (Enig Param)",
        "func": "const requestBody = msg.req.body;\nconst rows = requestBody.rows || 100; // Default to 100 if not provided.\nconst tableName = \"litmus.dbo.enigparam\"; // The table you are querying.\nlet queryBase = `SELECT TOP ${rows} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Check if params are provided and not empty\nif (requestBody.hasOwnProperty('params') && Object.keys(requestBody.params).length > 0) {\n  // Process the parameters for SQL query\n  Object.entries(requestBody.params).forEach(([param, conditions]) => {\n    // Add condition if 'ht' is specified\n    if (conditions.hasOwnProperty('ht')) {\n      whereConditions.push(`${param} >= @${param}_ht`);\n      queryParams.push({ name: `${param}_ht`, value: conditions['ht'], type: 'Float' });\n    }\n    // Add condition if 'lt' is specified\n    if (conditions.hasOwnProperty('lt')) {\n      whereConditions.push(`${param} <= @${param}_lt`);\n      queryParams.push({ name: `${param}_lt`, value: conditions['lt'], type: 'Float' });\n    }\n  });\n  \n  // Add WHERE clause to the query if there are any conditions\n  if (whereConditions.length) {\n    queryBase += ' WHERE ' + whereConditions.join(' AND ');\n  }\n}\n\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should now be correctly formatted for the MSSQL node.\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2230,
        "y": 460,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "bda6c4803cf5ca62",
        "type": "http response",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "statusCode": "409",
        "headers": {},
        "x": 3080,
        "y": 420,
        "wires": []
    },
    {
        "id": "9f69e9bc5aa2012a",
        "type": "switch",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "409",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 2930,
        "y": 440,
        "wires": [
            [
                "bda6c4803cf5ca62",
                "e761cca48bb70fb8"
            ],
            [
                "9d6d0581a2257046"
            ]
        ]
    },
    {
        "id": "6ee68dbd9ec725ef",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "function 23",
        "func": "// Function node to handle SQL errors and set HTTP response\nif (msg.error && msg.error.code === \"EREQUEST\") {\n    // Check if the error message contains 'duplicate key'\n    if (msg.error.message.includes('duplicate key')) {\n        msg.statusCode = 409; // HTTP 409 Conflict\n        msg.payload = {\n            error: \"Duplicate key error: cannot insert item with the same ID.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    } else {\n        // Handle other SQL errors here if necessary\n        msg.statusCode = 500;\n        msg.payload = {\n            error: \"A database error occurred.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    }\n} else {\n    msg.statusCode = 200;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2770,
        "y": 440,
        "wires": [
            [
                "9f69e9bc5aa2012a"
            ]
        ]
    },
    {
        "id": "9328a277b576adbc",
        "type": "catch",
        "z": "d516f4c69dd3bbfe",
        "name": "",
        "scope": [
            "54346154534ab1dd"
        ],
        "uncaught": false,
        "x": 2550,
        "y": 380,
        "wires": [
            [
                "6ee68dbd9ec725ef"
            ]
        ]
    },
    {
        "id": "3b75d0a8cdc2b636",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug 58",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 300,
        "wires": []
    },
    {
        "id": "a0d61685d959fc23",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "Configuration Object v2 (PCB Failure Analysis)",
        "func": "const requestBody = msg.req.body;\nconst rows = requestBody.rows || 100; // Default to 100 if not provided.\nconst tableName = \"litmus.dbo.PCBFailureAnalysis\"; // The table you are querying.\nlet queryBase = `SELECT TOP ${rows} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Check if params are provided and not empty\nif (requestBody.hasOwnProperty('params') && Object.keys(requestBody.params).length > 0) {\n  // Process the parameters for SQL query\n  Object.entries(requestBody.params).forEach(([param, conditions]) => {\n    // Add condition if 'ht' is specified\n    if (conditions.hasOwnProperty('ht')) {\n      whereConditions.push(`${param} >= @${param}_ht`);\n      queryParams.push({ name: `${param}_ht`, value: conditions['ht'], type: 'Float' });\n    }\n    // Add condition if 'lt' is specified\n    if (conditions.hasOwnProperty('lt')) {\n      whereConditions.push(`${param} <= @${param}_lt`);\n      queryParams.push({ name: `${param}_lt`, value: conditions['lt'], type: 'Float' });\n    }\n  });\n  \n  // Add WHERE clause to the query if there are any conditions\n  if (whereConditions.length) {\n    queryBase += ' WHERE ' + whereConditions.join(' AND ');\n  }\n}\n\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should now be correctly formatted for the MSSQL node.\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2260,
        "y": 540,
        "wires": [
            [
                "54346154534ab1dd"
            ]
        ]
    },
    {
        "id": "467f2345c93a5b4c",
        "type": "function",
        "z": "d516f4c69dd3bbfe",
        "name": "empty method",
        "func": "msg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2160,
        "y": 580,
        "wires": [
            [
                "9d6d0581a2257046"
            ]
        ]
    },
    {
        "id": "e761cca48bb70fb8",
        "type": "debug",
        "z": "d516f4c69dd3bbfe",
        "name": "debug 59",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3080,
        "y": 380,
        "wires": []
    },
    {
        "id": "34f34f8c9792994d",
        "type": "http in",
        "z": "aba326dbe5621f19",
        "name": "",
        "url": "/api/litmus/live/login",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 400,
        "wires": [
            [
                "b06b08ad0c5219fd",
                "6e2632cd9311fb13"
            ]
        ]
    },
    {
        "id": "b69e245bb8b7879f",
        "type": "comment",
        "z": "aba326dbe5621f19",
        "name": "Generic endpoint (Payload Basic Auth)",
        "info": "",
        "x": 230,
        "y": 80,
        "wires": []
    },
    {
        "id": "7c2f1f70c3e9d215",
        "type": "debug",
        "z": "aba326dbe5621f19",
        "name": "debug MSSQL",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 500,
        "wires": []
    },
    {
        "id": "9463d0385db06f16",
        "type": "MSSQL",
        "z": "aba326dbe5621f19",
        "mssqlCN": "99aa93fffde390a2",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "SELECT PasswordHash FROM litmus.dbo.api_user WHERE Username = @username",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "parameters",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 960,
        "y": 400,
        "wires": [
            [
                "7c2f1f70c3e9d215",
                "cf6a0a3a3d27f4bd"
            ]
        ]
    },
    {
        "id": "b06b08ad0c5219fd",
        "type": "debug",
        "z": "aba326dbe5621f19",
        "name": "debug HTTP IN",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 360,
        "wires": []
    },
    {
        "id": "e2ea744cd9aeb0c1",
        "type": "http response",
        "z": "aba326dbe5621f19",
        "name": "",
        "statusCode": "400",
        "headers": {},
        "x": 1080,
        "y": 360,
        "wires": []
    },
    {
        "id": "ee3422af16298a41",
        "type": "switch",
        "z": "aba326dbe5621f19",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "400",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 360,
        "wires": [
            [
                "e2ea744cd9aeb0c1"
            ]
        ]
    },
    {
        "id": "eb230fddeb5cba56",
        "type": "function",
        "z": "aba326dbe5621f19",
        "name": "Credentials Extraction ",
        "func": "let username = msg.payload.username;\nlet password = msg.payload.password;\n// Adjusted to consistently get the API key, ensuring we account for both direct payload and req.body\nlet apiKey = msg.payload.api_key || msg.req.body.api_key;\n\n// Determine the authentication method and set up accordingly\nif (apiKey) {\n    // For API key authentication\n    msg.authenticationMethod = 'apiKey';\n    msg.apiKey = apiKey;\n    // Adjusted for consistency in parameterization\n    msg.topic = `SELECT COUNT(apiKey) AS keyCount FROM litmus.dbo.api_key WHERE apiKey = @apiKey`;\n    msg.parameters = [\n        { name: \"apiKey\", value: msg.apiKey, type: \"VarChar\" }\n    ];\n} else if (username && password) {\n    // For username/password authentication\n    msg.authenticationMethod = 'usernamePassword';\n    // Ensure the query matches the parameterization style\n    msg.topic = 'SELECT password FROM litmus.dbo.users WHERE username = @username';\n    msg.parameters = [\n        { name: \"username\", value: username, type: \"VarChar\" }\n    ];\n    // Store provided password for comparison later\n    msg.providedPassword = password;\n} else {\n    // Neither method provided adequately\n    msg.payload = { success: false, message: \"Authentication requires either an API key or both username and password.\" };\n    msg.statusCode = 400; // Bad Request\n    return msg;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 400,
        "wires": [
            [
                "ee3422af16298a41",
                "9463d0385db06f16",
                "583cf8c28cf09802"
            ]
        ]
    },
    {
        "id": "6e2632cd9311fb13",
        "type": "rate-limiter",
        "z": "aba326dbe5621f19",
        "delay_action": "ratelimit",
        "rate": "60",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "drop_select": "drop",
        "addcurrentcount": false,
        "name": "",
        "outputs": "2",
        "buffer_size": "0",
        "buffer_drop": "buffer_drop_new",
        "emit_msg_2nd": true,
        "control_topic": "",
        "version": 0.0018,
        "x": 440,
        "y": 400,
        "wires": [
            [
                "6bbee8b92be443af",
                "eb230fddeb5cba56"
            ],
            [
                "f6def0194cc97d83"
            ]
        ]
    },
    {
        "id": "46ed362ebb1eaf17",
        "type": "http response",
        "z": "aba326dbe5621f19",
        "name": "Too Many Requests",
        "statusCode": "429",
        "headers": {},
        "x": 860,
        "y": 460,
        "wires": []
    },
    {
        "id": "f6def0194cc97d83",
        "type": "function",
        "z": "aba326dbe5621f19",
        "name": "Rate limit",
        "func": "msg.payload = {\n  \"error\": {\n    \"code\": 429,\n    \"message\": \"Too Many Requests.\",\n    \"description\": \"You have exceeded the request limit for this API. Please wait before sending more requests.\",\n    \"retry_after_seconds\": 60\n  }\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 460,
        "wires": [
            [
                "46ed362ebb1eaf17"
            ]
        ]
    },
    {
        "id": "6bbee8b92be443af",
        "type": "debug",
        "z": "aba326dbe5621f19",
        "name": "debug 51",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 360,
        "wires": []
    },
    {
        "id": "583cf8c28cf09802",
        "type": "debug",
        "z": "aba326dbe5621f19",
        "name": "debug 53",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 320,
        "wires": []
    },
    {
        "id": "cf6a0a3a3d27f4bd",
        "type": "http response",
        "z": "aba326dbe5621f19",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1180,
        "y": 400,
        "wires": []
    },
    {
        "id": "c3943c45032632a6",
        "type": "debug",
        "z": "5e4c90fefbab90d1",
        "name": "debug 56",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 220,
        "wires": []
    },
    {
        "id": "9fe3d93fc9567009",
        "type": "switch",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "409",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1790,
        "y": 280,
        "wires": [
            [
                "3320db735cead26e",
                "c3943c45032632a6"
            ],
            [
                "c8dfca2f4c270630"
            ]
        ]
    },
    {
        "id": "eac7ea46ae75842e",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "function 18",
        "func": "// Function node to handle SQL errors and set HTTP response\nif (msg.error && msg.error.code === \"EREQUEST\") {\n    // Check if the error message contains 'duplicate key'\n    if (msg.error.message.includes('duplicate key')) {\n        msg.statusCode = 409; // HTTP 409 Conflict\n        msg.payload = {\n            error: \"Duplicate key error: cannot insert item with the same ID.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    } else {\n        // Handle other SQL errors here if necessary\n        msg.statusCode = 500;\n        msg.payload = {\n            error: \"A database error occurred.\",\n            details: msg.error.message // Optional: include the SQL error message\n        };\n    }\n} else {\n    msg.statusCode = 200;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 280,
        "wires": [
            [
                "9fe3d93fc9567009"
            ]
        ]
    },
    {
        "id": "3320db735cead26e",
        "type": "http response",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "statusCode": "409",
        "headers": {},
        "x": 1940,
        "y": 260,
        "wires": []
    },
    {
        "id": "c8dfca2f4c270630",
        "type": "http response",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 1940,
        "y": 300,
        "wires": []
    },
    {
        "id": "5d2aea17334fed6a",
        "type": "MSSQL",
        "z": "5e4c90fefbab90d1",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "MSSQL-PLUS-2",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "queryMode",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "payload",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 1440,
        "y": 280,
        "wires": [
            [
                "58f67c0df0ba7e81",
                "eac7ea46ae75842e"
            ]
        ]
    },
    {
        "id": "a52e88aa08fcfc5e",
        "type": "catch",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "scope": [
            "5d2aea17334fed6a"
        ],
        "uncaught": false,
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "eac7ea46ae75842e"
            ]
        ]
    },
    {
        "id": "3d3395d6c6e15723",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "empty method",
        "func": "msg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 420,
        "wires": [
            [
                "c8dfca2f4c270630"
            ]
        ]
    },
    {
        "id": "9b043cb3fb805cc7",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (downtime History)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.downtimeHistory\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) { // Assuming an empty string is not a valid value\n        switch (param) {\n            case \"startDate\":\n                whereConditions.push(`startTime >= @startDate`);\n                queryParams.push({ name: 'startDate', value: value, type: 'VarChar' });\n                break;\n            case \"endDate\":\n                whereConditions.push(`endTime <= @endDate`);\n                queryParams.push({ name: 'endDate', value: value, type: 'VarChar' });\n                break;\n            case \"reasonCode_L1_text\":\n            case \"reasonCode_L2_text\":\n            case \"asset\":\n            case \"line\":\n                // Directly mapping other parameters to database columns\n                whereConditions.push(`${param} = @${param}`);\n                queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n                break;\n            // You can add more cases here if you have more parameters\n        }\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Append ORDER BY clause to sort by scrapTime in descending order\nqueryBase += \" ORDER BY startTime DESC\";\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 140,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "2ba68badc0542e79",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (scrap History)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.scrapHistory\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n        if (param === \"startDate\" || param === \"endDate\") {\n            const operator = param === \"startDate\" ? \">=\" : \"<=\";\n            whereConditions.push(`scrapTime ${operator} @${param}`);\n            queryParams.push({ name: param, value: value, type: 'VarChar' });\n        } else {\n            // For other parameters that directly map to database columns\n            whereConditions.push(`${param} = @${param}`);\n            queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n        }\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Append ORDER BY clause to sort by scrapTime in descending order\nqueryBase += \" ORDER BY scrapTime DESC\";\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1090,
        "y": 180,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "794cd0f8789638d5",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (scrap Codes)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.scrapCodes\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n       // For other parameters that directly map to database columns\n        whereConditions.push(`${param} = @${param}`);\n        queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1090,
        "y": 260,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "b614db3d08a3beef",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (incident User)",
        "func": "const requestBody = msg.req.body;\nlet rows = msg.req.body.rows;\nconst tableName = \"litmus.dbo.incident_user\"; // The table you are querying\nconst DEFAULT_ROWS = 100;\nlet queryBase = `SELECT TOP ${rows || DEFAULT_ROWS} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Dynamically construct the WHERE clause based on supplied parameters\nfor (const param in requestBody.params) {\n    const value = requestBody.params[param];\n    if (value) {  // Assuming an empty string is not a valid value\n       // For other parameters that directly map to database columns\n        whereConditions.push(`${param} = @${param}`);\n        queryParams.push({ name: param, value: value, type: 'VarChar' }); // Adjust the type as needed\n    }\n}\n\n// Combine all conditions to form the WHERE clause, if there are any conditions\nif (whereConditions.length > 0) {\n    queryBase += \" WHERE \" + whereConditions.join(\" AND \");\n}\n\n// Set the query and parameters for the MSSQL node\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should be an array of objects with name and value properties\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1090,
        "y": 220,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "6d625493b062bb4e",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (Inventory)",
        "func": "// Function node to construct batch SQL insert statements\nconst items = msg.payload.params;\nlet values = items.map(item => {\n    // Assuming 'item_id', 'item_name', and 'quantity' are strings; adapt as necessary\n    return `('${item.item_id}', '${item.item_name}', ${item.quantity})`;\n}).join(',');\n\nmsg.topic = `\n    INSERT INTO litmus.dbo.Inventory (item_id, item_name, quantity)\n    VALUES ${values};\n`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 340,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "b2aea94ceb3728b0",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (Enig Param)",
        "func": "const requestBody = msg.req.body;\nconst rows = requestBody.rows || 100; // Default to 100 if not provided.\nconst tableName = \"litmus.dbo.enigparam\"; // The table you are querying.\nlet queryBase = `SELECT TOP ${rows} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Check if params are provided and not empty\nif (requestBody.hasOwnProperty('params') && Object.keys(requestBody.params).length > 0) {\n  // Process the parameters for SQL query\n  Object.entries(requestBody.params).forEach(([param, conditions]) => {\n    // Add condition if 'ht' is specified\n    if (conditions.hasOwnProperty('ht')) {\n      whereConditions.push(`${param} >= @${param}_ht`);\n      queryParams.push({ name: `${param}_ht`, value: conditions['ht'], type: 'Float' });\n    }\n    // Add condition if 'lt' is specified\n    if (conditions.hasOwnProperty('lt')) {\n      whereConditions.push(`${param} <= @${param}_lt`);\n      queryParams.push({ name: `${param}_lt`, value: conditions['lt'], type: 'Float' });\n    }\n  });\n  \n  // Add WHERE clause to the query if there are any conditions\n  if (whereConditions.length) {\n    queryBase += ' WHERE ' + whereConditions.join(' AND ');\n  }\n}\n\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should now be correctly formatted for the MSSQL node.\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 300,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "4902b31e7f75d7f3",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Configuration Object v2 (PCB Failure Analysis)",
        "func": "const requestBody = msg.req.body;\nconst rows = requestBody.rows || 100; // Default to 100 if not provided.\nconst tableName = \"litmus.dbo.PCBFailureAnalysis\"; // The table you are querying.\nlet queryBase = `SELECT TOP ${rows} * FROM ${tableName}`;\nlet queryParams = [];\nlet whereConditions = [];\n\n// Check if params are provided and not empty\nif (requestBody.hasOwnProperty('params') && Object.keys(requestBody.params).length > 0) {\n  // Process the parameters for SQL query\n  Object.entries(requestBody.params).forEach(([param, conditions]) => {\n    // Add condition if 'ht' is specified\n    if (conditions.hasOwnProperty('ht')) {\n      whereConditions.push(`${param} >= @${param}_ht`);\n      queryParams.push({ name: `${param}_ht`, value: conditions['ht'], type: 'Float' });\n    }\n    // Add condition if 'lt' is specified\n    if (conditions.hasOwnProperty('lt')) {\n      whereConditions.push(`${param} <= @${param}_lt`);\n      queryParams.push({ name: `${param}_lt`, value: conditions['lt'], type: 'Float' });\n    }\n  });\n  \n  // Add WHERE clause to the query if there are any conditions\n  if (whereConditions.length) {\n    queryBase += ' WHERE ' + whereConditions.join(' AND ');\n  }\n}\n\nmsg.topic = queryBase;\nmsg.payload = queryParams; // This should now be correctly formatted for the MSSQL node.\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 380,
        "wires": [
            [
                "5d2aea17334fed6a"
            ]
        ]
    },
    {
        "id": "58f67c0df0ba7e81",
        "type": "debug",
        "z": "5e4c90fefbab90d1",
        "name": "debug MSSQL",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1640,
        "y": 220,
        "wires": []
    },
    {
        "id": "a21dd7501b53d7d5",
        "type": "switch",
        "z": "5e4c90fefbab90d1",
        "name": "Switch",
        "property": "req.body.method",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "getDowntimeHistory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getScrapHistory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getIncidentUser",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getScrapCodes",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getPCBEnig",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "updateInventory",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "getPCBFA",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "prev"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 810,
        "y": 200,
        "wires": [
            [
                "9b043cb3fb805cc7"
            ],
            [
                "2ba68badc0542e79"
            ],
            [
                "b614db3d08a3beef"
            ],
            [
                "794cd0f8789638d5"
            ],
            [
                "b2aea94ceb3728b0"
            ],
            [
                "6d625493b062bb4e"
            ],
            [
                "4902b31e7f75d7f3"
            ],
            [
                "3d3395d6c6e15723"
            ]
        ]
    },
    {
        "id": "fb416ec178aa08aa",
        "type": "switch",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "200",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "400",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 630,
        "y": 220,
        "wires": [
            [
                "a21dd7501b53d7d5"
            ],
            [
                "d22ba1c2f4108742"
            ]
        ]
    },
    {
        "id": "f8e72537b3fa45be",
        "type": "function",
        "z": "5e4c90fefbab90d1",
        "name": "Method validation",
        "func": "// Function node to validate 'method' attribute\nlet validMethods = ['getDowntimeHistory', 'getScrapHistory', 'getIncidentUser', 'getScrapCodes', 'getPCBEnig', 'updateInventory', 'getPCBFA']; // Add all your valid methods here\n\n// Check if the method is null or not in the list of valid methods\nif (msg.req.body.method === null || validMethods.indexOf(msg.req.body.method) === -1) {\n    // Set error message and stop the flow (you might want to send this to an HTTP response or similar)\n    //msg.payload = { error: \"Invalid or missing 'method' parameter.\" };\n    msg.statusCode = 200;\n    return msg; // Stops the flow if you're using a Switch or Function node to route messages based on their content\n} else {\n    // Continue with the flow if the method is valid\n    msg.statusCode = 200;\n    return msg;\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 220,
        "wires": [
            [
                "f824223680b2bbe9",
                "fb416ec178aa08aa"
            ]
        ]
    },
    {
        "id": "d22ba1c2f4108742",
        "type": "http response",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "statusCode": "400",
        "headers": {},
        "x": 780,
        "y": 280,
        "wires": []
    },
    {
        "id": "f824223680b2bbe9",
        "type": "debug",
        "z": "5e4c90fefbab90d1",
        "name": "debug method val",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 180,
        "wires": []
    },
    {
        "id": "01a248abe9826116",
        "type": "http in",
        "z": "5e4c90fefbab90d1",
        "name": "",
        "url": "/api/litmus/live/table",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 220,
        "wires": [
            [
                "f8e72537b3fa45be"
            ]
        ]
    },
    {
        "id": "67886f71d3c7dba1",
        "type": "http in",
        "z": "1edb4a8c4511a724",
        "name": "",
        "url": "/api/litmus/live/queriedData",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 240,
        "wires": [
            [
                "a2b552c8e5f944f5",
                "6e9e1976fc8b111a"
            ]
        ]
    },
    {
        "id": "1b40a618212d288b",
        "type": "http response",
        "z": "1edb4a8c4511a724",
        "name": "",
        "statusCode": "200",
        "headers": {},
        "x": 780,
        "y": 240,
        "wires": []
    },
    {
        "id": "a2b552c8e5f944f5",
        "type": "function",
        "z": "1edb4a8c4511a724",
        "name": "function 20",
        "func": "var table_name = msg.payload.table_name;\nvar rows = msg.payload.rows;\nvar selected_columns = msg.payload.selected_items.join(', '); // Join array into a string\nvar from_date = msg.payload.from_date;\nvar to_date = msg.payload.to_date;\nvar where_clause = msg.payload.where_clause.trim(); // The additional WHERE conditions\n\n// Start building the basic query\nvar query = `SELECT TOP(${rows}) ${selected_columns} FROM litmus.dbo.${table_name}`;\n\nvar whereParts = []; // Array to hold parts of the WHERE clause\n\n// Check if both from_date and to_date are provided\nif (from_date && to_date) {\n    whereParts.push(`CAST(InsertionTime AS DATE) >= '${from_date}'`);\n    whereParts.push(`CAST(InsertionTime AS DATE) <= '${to_date}'`);\n}\n\n// Append the where_clause if it exists and is not an empty string\nif (where_clause && where_clause.length > 0) {\n    whereParts.push(where_clause);\n}\n\n// Combine the WHERE parts with ' AND ' if there are any conditions\nif (whereParts.length > 0) {\n    query += ' WHERE ' + whereParts.join(' AND ');\n}\n\nmsg.topic = query;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 240,
        "wires": [
            [
                "c306a9ad53fe7a71"
            ]
        ]
    },
    {
        "id": "c306a9ad53fe7a71",
        "type": "MSSQL",
        "z": "1edb4a8c4511a724",
        "mssqlCN": "3a108e85f3c6ac98",
        "name": "",
        "outField": "payload",
        "returnType": 0,
        "throwErrors": 1,
        "query": "",
        "modeOpt": "",
        "modeOptType": "query",
        "queryOpt": "topic",
        "queryOptType": "msg",
        "paramsOpt": "queryParams",
        "paramsOptType": "msg",
        "rows": "rows",
        "rowsType": "msg",
        "parseMustache": true,
        "params": [],
        "x": 570,
        "y": 240,
        "wires": [
            [
                "1b40a618212d288b",
                "8fbf45e82676ac04"
            ]
        ]
    },
    {
        "id": "6e9e1976fc8b111a",
        "type": "debug",
        "z": "1edb4a8c4511a724",
        "name": "debug 54",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 360,
        "y": 200,
        "wires": []
    },
    {
        "id": "8fbf45e82676ac04",
        "type": "debug",
        "z": "1edb4a8c4511a724",
        "name": "debug 55",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 200,
        "wires": []
    }
]